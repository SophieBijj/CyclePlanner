<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#ec4899">
    <title>Lunarium 🌸</title>
    
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            background-color: #f9fafb;
        }
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 16px 24px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 10000;
            animation: slideIn 0.3s ease-out;
        }
        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        .cycle-segment {
            cursor: pointer;
            transition: opacity 0.2s;
        }
        .cycle-segment:hover {
            opacity: 0.85;
        }
        .sync-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid #e5e7eb;
            border-top-color: #3b82f6;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        /* Scrollbar visible sur mobile */
        .event-list-scroll::-webkit-scrollbar {
            width: 4px;
        }
        .event-list-scroll::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 2px;
        }
        .event-list-scroll::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 2px;
        }
        .event-list-scroll::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // CONFIGURATION GOOGLE CALENDAR API
        const GOOGLE_CLIENT_ID = '711219272291-i1je9vqn1b4p0asn4fov7bdohoa08q38.apps.googleusercontent.com';
        const GOOGLE_API_KEY = 'AIzaSyA81G3xJq6iTJitDv6GO_rvjaOucTpeDNA';
        const DISCOVERY_DOCS = [
            'https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest',
            'https://www.googleapis.com/discovery/v1/apis/tasks/v1/rest'
        ];
        const SCOPES = 'https://www.googleapis.com/auth/calendar https://www.googleapis.com/auth/tasks';

        // ===== ICÔNES =====
        const GoogleIcon = () => (
            <svg width="18" height="18" viewBox="0 0 24 24">
                <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
            </svg>
        );

        const PlusIcon = () => (
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <line x1="12" y1="5" x2="12" y2="19"></line>
                <line x1="5" y1="12" x2="19" y2="12"></line>
            </svg>
        );

        const EditIcon = () => (
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
            </svg>
        );

        const TrashIcon = () => (
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polyline points="3 6 5 6 21 6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
            </svg>
        );

        const SyncIcon = () => (
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polyline points="23 4 23 10 17 10"></polyline>
                <polyline points="1 20 1 14 7 14"></polyline>
                <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
            </svg>
        );

        const SettingsIcon = () => (
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <circle cx="12" cy="12" r="3"></circle>
                <path d="M12 1v6m0 6v6m5.66-17a10 10 0 0 1 0 16M6.34 4a10 10 0 0 0 0 16"></path>
            </svg>
        );

        const XIcon = () => (
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
        );

        // ===== FONCTIONS UTILITAIRES =====
        
        // Fonction pour obtenir les données du soleil via l'API Open-Meteo
        async function fetchSunTimes(date) {
            const lat = 45.5017; // Montréal
            const lng = -73.5673;
            
            const dateStr = date.toISOString().split('T')[0]; // Format YYYY-MM-DD
            
            try {
                const response = await fetch(
                    `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&daily=sunrise,sunset&start_date=${dateStr}&end_date=${dateStr}&timezone=auto`
                );
                const data = await response.json();
                
                if (data.daily && data.daily.sunrise && data.daily.sunset) {
                    // Les données sont déjà en heure locale grâce à timezone=auto
                    const sunriseStr = data.daily.sunrise[0]; // Format: "2025-11-18T07:30"
                    const sunsetStr = data.daily.sunset[0];
                    
                    const sunriseDate = new Date(sunriseStr);
                    const sunsetDate = new Date(sunsetStr);
                    
                    const formatTime = (date) => {
                        const hours = date.getHours();
                        const minutes = date.getMinutes();
                        return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
                    };
                    
                    return {
                        sunrise: formatTime(sunriseDate),
                        sunset: formatTime(sunsetDate),
                        sunriseDecimal: sunriseDate.getHours() + sunriseDate.getMinutes() / 60,
                        sunsetDecimal: sunsetDate.getHours() + sunsetDate.getMinutes() / 60
                    };
                }
            } catch (error) {
                console.error('Erreur lors de la récupération des données du soleil:', error);
            }
            
            // Fallback en cas d'erreur
            return { sunrise: '07:30', sunset: '17:00', sunriseDecimal: 7.5, sunsetDecimal: 17 };
        }

        function getPhaseInfo(cycleDay, cycleLength) {
            const ovulationDay = cycleLength - 14;
            
            if (cycleDay >= 1 && cycleDay <= 5) {
                return { 
                    name: 'Menstruation',
                    shortName: 'Lune rouge',
                    color: '#fca5a5', 
                    border: '#f87171', 
                    text: '#7f1d1d',
                    description: 'Repos, introspection, détoxification'
                };
            } else if (cycleDay >= 6 && cycleDay < ovulationDay - 1) {
                return { 
                    name: 'Folliculaire',
                    shortName: 'Jeune Fille',
                    color: '#67e8f9', 
                    border: '#06b6d4', 
                    text: '#164e63',
                    description: 'Créativité, nouveaux projets, brainstorming'
                };
            } else if (cycleDay >= ovulationDay - 1 && cycleDay <= ovulationDay + 1) {
                return { 
                    name: 'Ovulation',
                    shortName: 'Mère',
                    color: '#fcd34d', 
                    border: '#f59e0b', 
                    text: '#78350f',
                    description: 'Communication, collaboration, être présente'
                };
            } else if (cycleDay >= cycleLength - 1 && cycleDay <= cycleLength) {
                return { 
                    name: 'SPM',
                    shortName: 'SPM',
                    color: '#f0abfc', 
                    border: '#c026d3', 
                    text: '#701a75',
                    description: 'Détails, finition, laisser passer la vague'
                };
            } else {
                return { 
                    name: 'Lutéale',
                    shortName: 'Enchanteresse',
                    color: '#f0abfc', 
                    border: '#d946ef', 
                    text: '#701a75',
                    description: 'Intuition, focus, nettoyage'
                };
            }
        }

        function getMoonInfo(date) {
            // Nouvelle lune de référence: 21 octobre 2025, 13h25 UTC (récente pour meilleure précision)
            const knownNewMoon = new Date(Date.UTC(2025, 9, 21, 13, 25)); // mois 9 = octobre
            const lunarCycle = 29.53058867;
            
            const diff = date - knownNewMoon;
            const daysSinceKnownNewMoon = diff / (1000 * 60 * 60 * 24);
            let lunarAge = daysSinceKnownNewMoon % lunarCycle;
            
            // Gérer les dates avant la référence
            if (lunarAge < 0) lunarAge += lunarCycle;
            
            const phase = Math.floor((lunarAge / lunarCycle) * 8);
            
            const moonEmojis = ['🌑', '🌒', '🌓', '🌔', '🌕', '🌖', '🌗', '🌘'];
            const moonNames = ['Nouvelle lune', 'Premier croissant', 'Premier quartier', 'Gibbeuse croissante', 
                              'Pleine lune', 'Gibbeuse décroissante', 'Dernier quartier', 'Dernier croissant'];
            
            return { 
                emoji: moonEmojis[phase], 
                name: moonNames[phase],
                age: Math.round(lunarAge * 10) / 10
            };
        }

        // ===== GOOGLE TASKS =====
        const GoogleTasks = ({ isSignedIn, onTasksLoaded }) => {
            const [taskLists, setTaskLists] = useState([]);
            const [tasks, setTasks] = useState([]);
            const [selectedListId, setSelectedListId] = useState(null);
            const [isLoading, setIsLoading] = useState(false);
            const [newTaskTitle, setNewTaskTitle] = useState('');
            const [newTaskDate, setNewTaskDate] = useState('');
            const [showNewTask, setShowNewTask] = useState(false);

            useEffect(() => {
                if (isSignedIn && gapi.client) {
                    loadTaskLists();
                }
            }, [isSignedIn]);

            useEffect(() => {
                if (selectedListId) {
                    loadTasks(selectedListId);
                }
            }, [selectedListId]);

            const loadTaskLists = async () => {
                try {
                    const response = await gapi.client.request({
                        path: 'https://tasks.googleapis.com/tasks/v1/users/@me/lists'
                    });
                    const lists = response.result.items || [];
                    setTaskLists(lists);
                    if (lists.length > 0 && !selectedListId) {
                        setSelectedListId(lists[0].id);
                    }
                } catch (error) {
                    console.error('Erreur lors du chargement des listes de tâches:', error);
                }
            };

            const loadAllTasks = async () => {
                try {
                    const allTasks = [];
                    for (const list of taskLists) {
                        const response = await gapi.client.request({
                            path: `https://tasks.googleapis.com/tasks/v1/lists/${list.id}/tasks`,
                            params: { showCompleted: false, showHidden: false }
                        });
                        const listTasks = (response.result.items || []).map(task => ({
                            ...task,
                            listId: list.id,
                            listTitle: list.title
                        }));
                        allTasks.push(...listTasks);
                    }
                    if (onTasksLoaded) {
                        onTasksLoaded(allTasks);
                    }
                } catch (error) {
                    console.error('Erreur lors du chargement de toutes les tâches:', error);
                }
            };

            const loadTasks = async (listId) => {
                setIsLoading(true);
                try {
                    const response = await gapi.client.request({
                        path: `https://tasks.googleapis.com/tasks/v1/lists/${listId}/tasks`,
                        params: { showCompleted: true, showHidden: false }
                    });
                    setTasks(response.result.items || []);
                    // Charger toutes les tâches pour le calendrier
                    loadAllTasks();
                } catch (error) {
                    console.error('Erreur lors du chargement des tâches:', error);
                } finally {
                    setIsLoading(false);
                }
            };

            const addTask = async () => {
                if (!newTaskTitle.trim() || !selectedListId) return;

                try {
                    const taskData = {
                        title: newTaskTitle
                    };
                    
                    if (newTaskDate) {
                        // Google Tasks attend la date au format RFC 3339 (ISO 8601)
                        const dueDate = new Date(newTaskDate);
                        dueDate.setHours(12, 0, 0, 0); // Midi par défaut
                        taskData.due = dueDate.toISOString();
                    }

                    await gapi.client.request({
                        path: `https://tasks.googleapis.com/tasks/v1/lists/${selectedListId}/tasks`,
                        method: 'POST',
                        body: taskData
                    });
                    setNewTaskTitle('');
                    setNewTaskDate('');
                    setShowNewTask(false);
                    loadTasks(selectedListId);
                } catch (error) {
                    console.error('Erreur lors de l\'ajout de la tâche:', error);
                }
            };

            const toggleTask = async (taskId, currentStatus) => {
                try {
                    await gapi.client.request({
                        path: `https://tasks.googleapis.com/tasks/v1/lists/${selectedListId}/tasks/${taskId}`,
                        method: 'PATCH',
                        body: {
                            status: currentStatus === 'completed' ? 'needsAction' : 'completed'
                        }
                    });
                    loadTasks(selectedListId);
                } catch (error) {
                    console.error('Erreur lors de la mise à jour de la tâche:', error);
                }
            };

            const deleteTask = async (taskId) => {
                try {
                    await gapi.client.request({
                        path: `https://tasks.googleapis.com/tasks/v1/lists/${selectedListId}/tasks/${taskId}`,
                        method: 'DELETE'
                    });
                    loadTasks(selectedListId);
                } catch (error) {
                    console.error('Erreur lors de la suppression de la tâche:', error);
                }
            };

            const formatDate = (dateString) => {
                if (!dateString) return '';
                const date = new Date(dateString);
                return date.toLocaleDateString('fr-FR', { day: 'numeric', month: 'short' });
            };

            if (!isSignedIn) {
                return null;
            }

            return (
                <div style={{ 
                    padding: '12px', 
                    background: 'white', 
                    borderRadius: '8px', 
                    marginBottom: '12px', 
                    boxShadow: '0 1px 3px rgba(0,0,0,0.08)' 
                }}>
                    <div style={{ marginBottom: '12px' }}>
                        <h3 style={{ margin: '0 0 8px 0', fontSize: '14px', fontWeight: '600' }}>
                            ✓ Mes tâches
                        </h3>
                        
                        {taskLists.length > 0 && (
                            <select
                                value={selectedListId || ''}
                                onChange={(e) => setSelectedListId(e.target.value)}
                                style={{
                                    width: '100%',
                                    padding: '6px 8px',
                                    borderRadius: '6px',
                                    border: '1px solid #e5e7eb',
                                    fontSize: '12px',
                                    marginBottom: '8px'
                                }}
                            >
                                {taskLists.map(list => (
                                    <option key={list.id} value={list.id}>
                                        {list.title}
                                    </option>
                                ))}
                            </select>
                        )}

                        <button
                            onClick={() => setShowNewTask(!showNewTask)}
                            style={{
                                width: '100%',
                                padding: '6px 12px',
                                backgroundColor: '#f3f4f6',
                                border: '1px solid #e5e7eb',
                                borderRadius: '6px',
                                cursor: 'pointer',
                                fontSize: '12px',
                                fontWeight: '500',
                                color: '#6b7280'
                            }}
                        >
                            + Ajouter une tâche
                        </button>

                        {showNewTask && (
                            <div style={{ marginTop: '8px', display: 'flex', flexDirection: 'column', gap: '6px' }}>
                                <input
                                    type="text"
                                    value={newTaskTitle}
                                    onChange={(e) => setNewTaskTitle(e.target.value)}
                                    onKeyPress={(e) => e.key === 'Enter' && addTask()}
                                    placeholder="Titre de la tâche"
                                    style={{
                                        padding: '6px 8px',
                                        borderRadius: '6px',
                                        border: '1px solid #e5e7eb',
                                        fontSize: '12px'
                                    }}
                                    autoFocus
                                />
                                <input
                                    type="date"
                                    value={newTaskDate}
                                    onChange={(e) => setNewTaskDate(e.target.value)}
                                    style={{
                                        padding: '6px 8px',
                                        borderRadius: '6px',
                                        border: '1px solid #e5e7eb',
                                        fontSize: '12px'
                                    }}
                                />
                                <div style={{ display: 'flex', gap: '4px' }}>
                                    <button
                                        onClick={() => {
                                            setShowNewTask(false);
                                            setNewTaskTitle('');
                                            setNewTaskDate('');
                                        }}
                                        style={{
                                            flex: 1,
                                            padding: '6px 12px',
                                            backgroundColor: '#f3f4f6',
                                            color: '#6b7280',
                                            border: 'none',
                                            borderRadius: '6px',
                                            cursor: 'pointer',
                                            fontSize: '12px',
                                            fontWeight: '500'
                                        }}
                                    >
                                        Annuler
                                    </button>
                                    <button
                                        onClick={addTask}
                                        style={{
                                            flex: 1,
                                            padding: '6px 12px',
                                            backgroundColor: '#ec4899',
                                            color: 'white',
                                            border: 'none',
                                            borderRadius: '6px',
                                            cursor: 'pointer',
                                            fontSize: '12px',
                                            fontWeight: '500'
                                        }}
                                    >
                                        Ajouter
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>

                    {isLoading ? (
                        <div style={{ textAlign: 'center', padding: '12px', color: '#9ca3af', fontSize: '12px' }}>
                            Chargement...
                        </div>
                    ) : (
                        <div style={{ 
                            maxHeight: '300px', 
                            overflowY: 'auto',
                            display: 'flex',
                            flexDirection: 'column',
                            gap: '4px'
                        }}>
                            {tasks.length === 0 ? (
                                <div style={{ textAlign: 'center', padding: '12px', color: '#9ca3af', fontSize: '12px' }}>
                                    Aucune tâche
                                </div>
                            ) : (
                                tasks.map(task => (
                                    <div
                                        key={task.id}
                                        style={{
                                            display: 'flex',
                                            alignItems: 'flex-start',
                                            gap: '8px',
                                            padding: '6px 8px',
                                            borderRadius: '6px',
                                            background: task.status === 'completed' ? '#f9fafb' : 'white',
                                            border: '1px solid #f3f4f6'
                                        }}
                                    >
                                        <input
                                            type="checkbox"
                                            checked={task.status === 'completed'}
                                            onChange={() => toggleTask(task.id, task.status)}
                                            style={{ cursor: 'pointer', flexShrink: 0, marginTop: '2px' }}
                                        />
                                        <div style={{ flex: 1 }}>
                                            <div style={{
                                                fontSize: '12px',
                                                textDecoration: task.status === 'completed' ? 'line-through' : 'none',
                                                color: task.status === 'completed' ? '#9ca3af' : '#374151',
                                                lineHeight: '1.3',
                                                marginBottom: task.due ? '2px' : '0'
                                            }}>
                                                {task.title}
                                            </div>
                                            {task.due && (
                                                <div style={{
                                                    fontSize: '10px',
                                                    color: '#9ca3af'
                                                }}>
                                                    📅 {formatDate(task.due)}
                                                </div>
                                            )}
                                        </div>
                                        <button
                                            onClick={() => deleteTask(task.id)}
                                            style={{
                                                padding: '2px 6px',
                                                backgroundColor: 'transparent',
                                                color: '#ef4444',
                                                border: 'none',
                                                borderRadius: '4px',
                                                cursor: 'pointer',
                                                fontSize: '10px',
                                                flexShrink: 0
                                            }}
                                        >
                                            ✕
                                        </button>
                                    </div>
                                ))
                            )}
                        </div>
                    )}
                </div>
            );
        };

        // ===== GOOGLE CALENDAR SYNC =====
        const GoogleCalendarSync = ({ onSync, onError, onCalendarsLoaded, onSyncRequest }) => {
            const [isSignedIn, setIsSignedIn] = useState(false);
            const [isSyncing, setIsSyncing] = useState(false);
            const [calendars, setCalendars] = useState([]);
            const [selectedCalendars, setSelectedCalendars] = useState([]);
            const [isLoading, setIsLoading] = useState(true);
            const gapiInited = useRef(false);
            const gisInited = useRef(false);
            const tokenClient = useRef(null);

            // Exposer handleSync au parent via callback
            useEffect(() => {
                if (onSyncRequest && isSignedIn && selectedCalendars.length > 0) {
                    onSyncRequest(() => handleSync);
                }
            }, [isSignedIn, selectedCalendars]);

            useEffect(() => {
                let gapiTimeout, gisTimeout;
                
                const checkAndLoad = () => {
                    if (typeof gapi !== 'undefined') {
                        gapiLoaded();
                        clearTimeout(gapiTimeout);
                    } else {
                        gapiTimeout = setTimeout(checkAndLoad, 200);
                    }
                };
                
                const checkAndLoadGis = () => {
                    if (typeof google !== 'undefined' && google.accounts) {
                        gisLoaded();
                        clearTimeout(gisTimeout);
                    } else {
                        gisTimeout = setTimeout(checkAndLoadGis, 200);
                    }
                };
                
                setTimeout(() => {
                    checkAndLoad();
                    checkAndLoadGis();
                }, 500);
                
                setTimeout(() => {
                    if (!gapiInited.current || !gisInited.current) {
                        setIsLoading(false);
                        onError?.('Impossible de charger Google Calendar. Veuillez recharger la page.');
                    }
                }, 10000);
                
                return () => {
                    clearTimeout(gapiTimeout);
                    clearTimeout(gisTimeout);
                };
            }, []);

            const gapiLoaded = () => {
                if (typeof gapi !== 'undefined') {
                    gapi.load('client', initializeGapiClient);
                }
            };

            const initializeGapiClient = async () => {
                try {
                    // Initialiser uniquement Calendar avec API Key
                    await gapi.client.init({
                        apiKey: GOOGLE_API_KEY,
                        discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest'],
                    });
                    
                    gapiInited.current = true;
                    maybeEnableButtons();
                } catch (err) {
                    console.error('Error initializing GAPI:', err);
                    onError?.('Erreur d\'initialisation Google API');
                }
            };
            
            const loadTasksAPI = async () => {
                try {
                    // Charger Tasks API après authentification (sans API Key)
                    if (!window.tasksApiLoaded) {
                        await gapi.client.load('tasks', 'v1');
                        window.tasksApiLoaded = true;
                        console.log('Tasks API loaded successfully');
                    }
                } catch (err) {
                    console.error('Error loading Tasks API:', err);
                }
            };

            const gisLoaded = () => {
                if (typeof google !== 'undefined') {
                    tokenClient.current = google.accounts.oauth2.initTokenClient({
                        client_id: GOOGLE_CLIENT_ID,
                        scope: SCOPES,
                        callback: async (response) => {
                            if (response.error) {
                                console.error('Auth error:', response.error);
                                onError?.('Erreur d\'authentification Google');
                                return;
                            }
                            
                            // Sauvegarder le token pour persistance
                            if (response.access_token) {
                                const expiresAt = Date.now() + (response.expires_in * 1000);
                                localStorage.setItem('googleAccessToken', JSON.stringify({
                                    access_token: response.access_token,
                                    expires_at: expiresAt
                                }));
                                
                                // Définir le token dans gapi
                                gapi.client.setToken({
                                    access_token: response.access_token
                                });
                                
                                // Charger Tasks API maintenant qu'on est authentifié
                                await loadTasksAPI();
                            }
                            
                            setIsSignedIn(true);
                            await loadCalendars(); // loadCalendars s'occupe de l'auto-sync
                        },
                    });
                    gisInited.current = true;
                    maybeEnableButtons();
                }
            };

            const maybeEnableButtons = () => {
                if (gapiInited.current && gisInited.current) {
                    setIsLoading(false);
                    
                    // Essayer de restaurer le token depuis localStorage
                    const savedToken = localStorage.getItem('googleAccessToken');
                    if (savedToken) {
                        try {
                            const tokenData = JSON.parse(savedToken);
                            
                            // Vérifier si le token n'est pas expiré
                            if (tokenData.expires_at && Date.now() < tokenData.expires_at) {
                                console.log('Restoring saved token...');
                                gapi.client.setToken({
                                    access_token: tokenData.access_token
                                });
                            } else {
                                console.log('Saved token expired, clearing...');
                                localStorage.removeItem('googleAccessToken');
                            }
                        } catch (e) {
                            console.error('Error restoring token:', e);
                            localStorage.removeItem('googleAccessToken');
                        }
                    }
                    
                    // Vérifier si on a un token valide
                    const token = gapi.client.getToken();
                    if (token !== null) {
                        console.log('Already signed in, loading calendars...');
                        setIsSignedIn(true);
                        
                        // Charger Tasks API avec le token restauré
                        loadTasksAPI().then(() => {
                            loadCalendars(); // loadCalendars s'occupe maintenant de l'auto-sync
                        });
                    }
                }
            };

            const handleAuthClick = () => {
                if (!tokenClient.current) {
                    onError?.('Initialisation en cours, veuillez réessayer dans quelques secondes');
                    return;
                }
                
                if (typeof gapi === 'undefined' || !gapi.client) {
                    onError?.('Google API en cours de chargement, veuillez réessayer');
                    return;
                }
                
                if (gapi.client.getToken() === null) {
                    tokenClient.current.requestAccessToken({ prompt: 'consent' });
                } else {
                    tokenClient.current.requestAccessToken({ prompt: '' });
                }
            };

            const handleSignoutClick = () => {
                if (typeof gapi === 'undefined' || !gapi.client) return;
                
                const token = gapi.client.getToken();
                if (token !== null) {
                    google.accounts.oauth2.revoke(token.access_token);
                    gapi.client.setToken('');
                    
                    // Supprimer le token sauvegardé
                    localStorage.removeItem('googleAccessToken');
                    
                    setIsSignedIn(false);
                    setCalendars([]);
                    setSelectedCalendars([]);
                }
            };

            const loadCalendars = async () => {
                if (typeof gapi === 'undefined' || !gapi.client) return;
                
                try {
                    const response = await gapi.client.calendar.calendarList.list();
                    const cals = response.result.items || [];
                    console.log('=== ALL CALENDARS ===');
                    cals.forEach(cal => {
                        console.log(`Calendar: "${cal.summary}" | ID: ${cal.id} | Color: ${cal.backgroundColor}`);
                    });
                    console.log('===================');
                    
                    // Ajouter un calendrier virtuel pour les tâches
                    const tasksCalendar = {
                        id: '__TASKS__',
                        summary: '✓ Tâches',
                        backgroundColor: '#F59E0B', // Orange/amber
                        foregroundColor: '#000000',
                        isTasksCalendar: true
                    };
                    
                    const allCalendars = [...cals, tasksCalendar];
                    setCalendars(allCalendars);
                    onCalendarsLoaded?.(allCalendars); // Exposer les calendriers au parent
                    
                    // Restaurer les calendriers sélectionnés depuis localStorage
                    const savedCalendars = localStorage.getItem('selectedCalendars');
                    if (savedCalendars) {
                        try {
                            const saved = JSON.parse(savedCalendars);
                            // Vérifier que les calendriers sauvegardés existent toujours
                            let validSaved = saved.filter(id => allCalendars.some(cal => cal.id === id));

                            // Migration : ajouter __TASKS__ s'il n'est pas déjà dans la liste
                            if (validSaved.length > 0 && !validSaved.includes('__TASKS__')) {
                                console.log('Migration: adding __TASKS__ to saved calendars');
                                validSaved.push('__TASKS__');
                                localStorage.setItem('selectedCalendars', JSON.stringify(validSaved));
                            }

                            if (validSaved.length > 0) {
                                console.log('Restoring selected calendars:', validSaved);
                                setSelectedCalendars(validSaved);

                                // Auto-sync en passant directement les calendriers pour éviter problème de timing React
                                setTimeout(() => {
                                    console.log('Auto-syncing with restored calendars...');
                                    handleSync(validSaved); // Passer les calendriers directement
                                }, 1000);

                                return; // Ne pas sélectionner le principal par défaut
                            }
                        } catch (e) {
                            console.error('Error parsing saved calendars:', e);
                        }
                    }
                    
                    // Si pas de calendriers sauvegardés, sélectionner le principal + les tâches
                    const primary = cals.find(cal => cal.primary);
                    if (primary) {
                        const defaultSelection = [primary.id, '__TASKS__'];
                        setSelectedCalendars(defaultSelection);
                        localStorage.setItem('selectedCalendars', JSON.stringify(defaultSelection));

                        // Auto-sync avec la sélection par défaut
                        setTimeout(() => {
                            console.log('Auto-syncing with default calendars...');
                            handleSync(defaultSelection);
                        }, 1000);
                    }
                } catch (err) {
                    console.error('Error loading calendars:', err);
                    onError?.('Erreur de chargement des calendriers');
                }
            };

            const handleSync = async (calendarsToSync = null) => {
                const calendarIds = calendarsToSync || selectedCalendars;
                
                if (calendarIds.length === 0) {
                    console.log('Cannot sync: no calendars selected');
                    return;
                }
                if (typeof gapi === 'undefined' || !gapi.client) {
                    onError?.('Google API non disponible');
                    return;
                }
                
                // Vérifier qu'on a un token valide
                const token = gapi.client.getToken();
                if (!token) {
                    console.log('Cannot sync: no valid token');
                    return;
                }
                
                setIsSyncing(true);
                try {
                    const now = new Date();
                    const sixMonthsAgo = new Date(now.getFullYear(), now.getMonth() - 6, 1);
                    const sixMonthsAhead = new Date(now.getFullYear(), now.getMonth() + 6, 31);
                    
                    const allEvents = [];
                    const calendarMap = {};
                    
                    // Séparer les calendriers normaux et le calendrier des tâches
                    const regularCalendars = calendarIds.filter(id => id !== '__TASKS__');
                    const includesTasks = calendarIds.includes('__TASKS__');
                    
                    // Charger les événements des calendriers normaux
                    for (const calendarId of regularCalendars) {
                        console.log('Fetching events from calendar:', calendarId);
                        const calInfo = calendars.find(c => c.id === calendarId);
                        if (calInfo) {
                            calendarMap[calendarId] = calInfo.backgroundColor || '#3b82f6';
                        }
                        
                        const response = await gapi.client.calendar.events.list({
                            calendarId: calendarId,
                            timeMin: sixMonthsAgo.toISOString(),
                            timeMax: sixMonthsAhead.toISOString(),
                            singleEvents: true,
                            orderBy: 'startTime',
                        });
                        
                        const events = response.result.items || [];
                        console.log(`Found ${events.length} events in calendar ${calendarId}`);
                        allEvents.push(...events.map(e => ({ ...e, calendarId })));
                    }
                    
                    // Charger les tâches si le calendrier des tâches est sélectionné
                    if (includesTasks) {
                        console.log('Fetching tasks...');
                        calendarMap['__TASKS__'] = '#F59E0B';

                        try {
                            // Vérifier que l'API Tasks est chargée
                            if (!gapi.client.tasks) {
                                console.warn('Tasks API not loaded, attempting to load...');
                                await loadTasksAPI();
                            }

                            // Vérifier à nouveau après le chargement
                            if (!gapi.client.tasks) {
                                throw new Error('Tasks API unavailable - please check API permissions');
                            }

                            // Récupérer toutes les task lists
                            const taskListsResponse = await gapi.client.tasks.tasklists.list();
                            const taskLists = taskListsResponse.result.items || [];
                            console.log(`Found ${taskLists.length} task lists`);
                            
                            // Pour chaque task list, récupérer les tâches
                            for (const taskList of taskLists) {
                                const tasksResponse = await gapi.client.tasks.tasks.list({
                                    tasklist: taskList.id,
                                    showCompleted: true,
                                    showHidden: false
                                });
                                
                                const tasks = tasksResponse.result.items || [];
                                console.log(`Found ${tasks.length} tasks in list "${taskList.title}"`);
                                
                                // Convertir les tâches en format d'événement
                                for (const task of tasks) {
                                    // Déterminer la date d'affichage : date d'échéance ou date du jour
                                    let displayDate;
                                    if (task.due) {
                                        displayDate = new Date(task.due);
                                    } else {
                                        // Tâches sans date d'échéance : afficher à la date du jour
                                        displayDate = new Date(now);
                                        displayDate.setHours(0, 0, 0, 0);
                                    }

                                    // Vérifier si la date est dans notre fenêtre temporelle
                                    if (displayDate >= sixMonthsAgo && displayDate <= sixMonthsAhead) {
                                        const dateString = displayDate.toISOString().split('T')[0];

                                        allEvents.push({
                                            id: task.id,
                                            summary: task.title || 'Sans titre',
                                            description: task.notes || '',
                                            start: {
                                                date: dateString,
                                                dateTime: null
                                            },
                                            end: {
                                                date: dateString,
                                                dateTime: null
                                            },
                                            calendarId: '__TASKS__',
                                            isTask: true,
                                            taskListId: taskList.id,
                                            taskListTitle: taskList.title,
                                            status: task.status, // 'needsAction' ou 'completed'
                                            hasNoDueDate: !task.due, // Indicateur pour les tâches sans échéance
                                            completed: task.completed || null
                                        });
                                    }
                                }
                            }
                        } catch (taskErr) {
                            console.error('Error fetching tasks:', taskErr);
                            // Afficher un message informatif à l'utilisateur
                            if (taskErr.message && taskErr.message.includes('unavailable')) {
                                onError?.('⚠️ API Tasks non disponible. Événements synchronisés, mais les tâches ne sont pas chargées.');
                            } else {
                                onError?.('⚠️ Erreur lors du chargement des tâches. Événements synchronisés.');
                            }
                            // Ne pas bloquer la synchro complète si les tâches échouent
                        }
                    }
                    
                    console.log(`Total events found: ${allEvents.length}`);
                    onSync?.(allEvents, calendarMap);
                } catch (err) {
                    console.error('Error syncing:', err);
                    onError?.('Erreur de synchronisation');
                } finally {
                    setIsSyncing(false);
                }
            };

            const toggleCalendar = (calendarId) => {
                const newSelected = selectedCalendars.includes(calendarId)
                    ? selectedCalendars.filter(id => id !== calendarId)
                    : [...selectedCalendars, calendarId];
                
                setSelectedCalendars(newSelected);
                localStorage.setItem('selectedCalendars', JSON.stringify(newSelected));
            };

            return (
                <div style={{ padding: '12px', background: 'white', borderRadius: '8px', marginBottom: '12px', boxShadow: '0 1px 3px rgba(0,0,0,0.08)' }}>
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}>
                        <h3 style={{ margin: 0, fontSize: '14px', fontWeight: '600', display: 'flex', alignItems: 'center', gap: '6px' }}>
                            <GoogleIcon />
                            Calendriers
                        </h3>
                        {!isSignedIn ? (
                            <button
                                onClick={handleAuthClick}
                                disabled={isLoading}
                                style={{
                                    padding: '8px 12px',
                                    backgroundColor: isLoading ? '#9ca3af' : '#4285F4',
                                    color: 'white',
                                    borderRadius: '6px',
                                    fontWeight: '500',
                                    cursor: isLoading ? 'not-allowed' : 'pointer',
                                    border: 'none',
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    gap: '6px',
                                    fontSize: '13px',
                                    width: '100%'
                                }}
                            >
                                <GoogleIcon />
                                {isLoading ? 'Chargement...' : 'Se connecter'}
                            </button>
                        ) : (
                            <div style={{ display: 'flex', flexDirection: 'column', gap: '6px' }}>
                                <button
                                    onClick={() => handleSync()}
                                    disabled={isSyncing || selectedCalendars.length === 0}
                                    style={{
                                        padding: '8px 12px',
                                        backgroundColor: isSyncing ? '#9ca3af' : '#16a34a',
                                        color: 'white',
                                        borderRadius: '6px',
                                        fontWeight: '500',
                                        cursor: isSyncing || selectedCalendars.length === 0 ? 'not-allowed' : 'pointer',
                                        border: 'none',
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'center',
                                        gap: '6px',
                                        fontSize: '13px',
                                        width: '100%'
                                    }}
                                >
                                    <SyncIcon />
                                    {isSyncing ? 'Synchro...' : 'Synchroniser'}
                                </button>
                                <button
                                    onClick={handleSignoutClick}
                                    style={{
                                        padding: '6px 12px',
                                        backgroundColor: 'transparent',
                                        color: '#ef4444',
                                        borderRadius: '6px',
                                        fontWeight: '500',
                                        cursor: 'pointer',
                                        border: '1px solid #fecaca',
                                        fontSize: '12px',
                                        width: '100%'
                                    }}
                                >
                                    Déconnecter
                                </button>
                            </div>
                        )}
                    </div>

                    {isSignedIn && calendars.length > 0 && (
                        <div style={{ marginTop: '12px' }}>
                            <p style={{ fontSize: '12px', color: '#6b7280', marginBottom: '8px', fontWeight: '500' }}>
                                Mes calendriers :
                            </p>
                            <div style={{ display: 'flex', flexDirection: 'column', gap: '6px' }}>
                                {calendars.map(cal => (
                                    <label
                                        key={cal.id}
                                        style={{
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: '8px',
                                            padding: '6px 8px',
                                            borderRadius: '6px',
                                            cursor: 'pointer',
                                            background: selectedCalendars.includes(cal.id) ? '#f0fdf4' : 'transparent',
                                            transition: 'background 0.2s'
                                        }}
                                        onMouseEnter={(e) => {
                                            if (!selectedCalendars.includes(cal.id)) {
                                                e.currentTarget.style.background = '#f9fafb';
                                            }
                                        }}
                                        onMouseLeave={(e) => {
                                            if (!selectedCalendars.includes(cal.id)) {
                                                e.currentTarget.style.background = 'transparent';
                                            }
                                        }}
                                    >
                                        <input
                                            type="checkbox"
                                            checked={selectedCalendars.includes(cal.id)}
                                            onChange={() => toggleCalendar(cal.id)}
                                            style={{ cursor: 'pointer', flexShrink: 0 }}
                                        />
                                        <div
                                            style={{
                                                width: '10px',
                                                height: '10px',
                                                borderRadius: '50%',
                                                backgroundColor: cal.backgroundColor || '#3b82f6',
                                                flexShrink: 0
                                            }}
                                        />
                                        <span style={{ fontSize: '13px', lineHeight: '1.2', overflow: 'hidden', textOverflow: 'ellipsis' }}>
                                            {cal.summary}
                                        </span>
                                    </label>
                                ))}
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // ===== MONTH VIEW =====
        const MonthView = ({ 
            currentMonth, 
            onMonthChange, 
            activities, 
            getPhaseForDate, 
            onDayClick,
            googleCalendars 
        }) => {
            const daysInMonth = new Date(currentMonth.getFullYear(), currentMonth.getMonth() + 1, 0).getDate();
            const firstDayOfMonth = new Date(currentMonth.getFullYear(), currentMonth.getMonth(), 1);
            const startingDayOfWeek = firstDayOfMonth.getDay();
            
            const monthName = currentMonth.toLocaleDateString('fr-FR', { month: 'long', year: 'numeric' });
            
            const prevMonth = () => {
                const newMonth = new Date(currentMonth);
                newMonth.setMonth(newMonth.getMonth() - 1);
                onMonthChange(newMonth);
            };
            
            const nextMonth = () => {
                const newMonth = new Date(currentMonth);
                newMonth.setMonth(newMonth.getMonth() + 1);
                onMonthChange(newMonth);
            };
            
            const formatDate = (date) => {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            };
            
            // Créer les jours du calendrier
            const calendarDays = [];
            
            // Jours vides au début
            for (let i = 0; i < startingDayOfWeek; i++) {
                calendarDays.push(null);
            }
            
            // Jours du mois
            for (let day = 1; day <= daysInMonth; day++) {
                const date = new Date(currentMonth.getFullYear(), currentMonth.getMonth(), day);
                calendarDays.push(date);
            }
            
            return (
                <div style={{ width: '100%' }}>
                    {/* Navigation mois */}
                    <div style={{ 
                        display: 'flex', 
                        justifyContent: 'space-between', 
                        alignItems: 'center',
                        marginBottom: '20px'
                    }}>
                        <button
                            onClick={prevMonth}
                            style={{
                                padding: '8px 16px',
                                backgroundColor: 'white',
                                border: '1px solid #e5e7eb',
                                borderRadius: '8px',
                                cursor: 'pointer',
                                fontSize: '14px',
                                fontWeight: '500'
                            }}
                        >
                            ← Mois précédent
                        </button>
                        <h2 style={{ 
                            margin: 0, 
                            fontSize: '18px', 
                            fontWeight: '600',
                            textTransform: 'capitalize'
                        }}>
                            {monthName}
                        </h2>
                        <button
                            onClick={nextMonth}
                            style={{
                                padding: '8px 16px',
                                backgroundColor: 'white',
                                border: '1px solid #e5e7eb',
                                borderRadius: '8px',
                                cursor: 'pointer',
                                fontSize: '14px',
                                fontWeight: '500'
                            }}
                        >
                            Mois suivant →
                        </button>
                    </div>
                    
                    {/* Calendrier */}
                    <div style={{
                        display: 'grid',
                        gridTemplateColumns: 'repeat(7, 1fr)',
                        gap: '4px'
                    }}>
                        {/* En-têtes des jours */}
                        {['Dim', 'Lun', 'Mar', 'Mer', 'Jeu', 'Ven', 'Sam'].map(day => (
                            <div key={day} style={{
                                padding: '12px',
                                textAlign: 'center',
                                fontSize: '12px',
                                fontWeight: '600',
                                color: '#6b7280'
                            }}>
                                {day}
                            </div>
                        ))}
                        
                        {/* Cellules du calendrier */}
                        {calendarDays.map((date, index) => {
                            if (!date) {
                                return <div key={`empty-${index}`} style={{ padding: '8px' }} />;
                            }
                            
                            const phaseInfo = getPhaseForDate(date);
                            const dateKey = formatDate(date);
                            const dayActivities = activities[dateKey] || [];
                            const isToday = formatDate(date) === formatDate(new Date());
                            
                            return (
                                <div
                                    key={dateKey}
                                    onClick={() => onDayClick(date)}
                                    style={{
                                        minHeight: '100px',
                                        padding: '8px',
                                        backgroundColor: phaseInfo.color + '15',
                                        border: isToday ? `2px solid ${phaseInfo.color}` : '1px solid #e5e7eb',
                                        borderRadius: '8px',
                                        cursor: 'pointer',
                                        transition: 'all 0.2s',
                                        ':hover': {
                                            transform: 'scale(1.02)',
                                            boxShadow: '0 2px 8px rgba(0,0,0,0.1)'
                                        }
                                    }}
                                    onMouseEnter={(e) => {
                                        e.currentTarget.style.transform = 'scale(1.02)';
                                        e.currentTarget.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)';
                                    }}
                                    onMouseLeave={(e) => {
                                        e.currentTarget.style.transform = 'scale(1)';
                                        e.currentTarget.style.boxShadow = 'none';
                                    }}
                                >
                                    <div style={{
                                        display: 'flex',
                                        justifyContent: 'space-between',
                                        alignItems: 'center',
                                        marginBottom: '4px'
                                    }}>
                                        <span style={{
                                            fontSize: '14px',
                                            fontWeight: isToday ? '700' : '500',
                                            color: isToday ? phaseInfo.color : '#374151'
                                        }}>
                                            {date.getDate()}
                                        </span>
                                        <span style={{
                                            fontSize: '10px',
                                            color: phaseInfo.text,
                                            fontWeight: '600',
                                            backgroundColor: phaseInfo.color + '30',
                                            padding: '2px 6px',
                                            borderRadius: '4px'
                                        }}>
                                            {phaseInfo.shortName}
                                        </span>
                                    </div>
                                    
                                    {/* Événements */}
                                    <div style={{ 
                                        display: 'flex', 
                                        flexDirection: 'column', 
                                        gap: '2px',
                                        maxHeight: '70px',
                                        overflow: 'hidden'
                                    }}>
                                        {dayActivities.slice(0, 3).map((activity, idx) => (
                                            <div
                                                key={idx}
                                                style={{
                                                    fontSize: '10px',
                                                    padding: '2px 4px',
                                                    backgroundColor: activity.color,
                                                    color: 'white',
                                                    borderRadius: '3px',
                                                    overflow: 'hidden',
                                                    textOverflow: 'ellipsis',
                                                    whiteSpace: 'nowrap',
                                                    display: 'flex',
                                                    alignItems: 'center',
                                                    gap: '3px'
                                                }}
                                            >
                                                {activity.isTask ? '✓' : activity.startTime}
                                                {activity.title}
                                            </div>
                                        ))}
                                        {dayActivities.length > 3 && (
                                            <div style={{
                                                fontSize: '9px',
                                                color: '#6b7280',
                                                fontWeight: '500'
                                            }}>
                                                +{dayActivities.length - 3} autres
                                            </div>
                                        )}
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        };

        // ===== CONFIG MODAL =====
        const ConfigModal = ({ config, cycleHistory, onSave, onClose }) => {
            const [startDate, setStartDate] = useState(config.cycleStartDate.toISOString().split('T')[0]);
            const [cycleLength, setCycleLength] = useState(config.cycleLength);
            const [history, setHistory] = useState(cycleHistory || []);

            const addCycleToHistory = () => {
                if (history.length < 12) {
                    setHistory([...history, { startDate: '' }]);
                }
            };

            const removeCycleFromHistory = (index) => {
                setHistory(history.filter((_, i) => i !== index));
            };

            const updateHistoryItem = (index, value) => {
                const newHistory = [...history];
                newHistory[index].startDate = value;
                setHistory(newHistory);
            };

            // Calculer les durées des cycles automatiquement
            const calculateCycleLengths = (historyDates, currentStart) => {
                if (historyDates.length === 0) return [];
                
                // Trier les dates par ordre chronologique (plus anciennes en premier)
                const sortedHistory = [...historyDates]
                    .filter(h => h.startDate)
                    .sort((a, b) => new Date(a.startDate) - new Date(b.startDate));
                
                const result = [];
                
                for (let i = 0; i < sortedHistory.length; i++) {
                    const currentDate = new Date(sortedHistory[i].startDate);
                    let nextDate;
                    
                    if (i < sortedHistory.length - 1) {
                        // Pas le dernier : utiliser le prochain cycle de l'historique
                        nextDate = new Date(sortedHistory[i + 1].startDate);
                    } else {
                        // Le dernier : utiliser le cycle actuel
                        nextDate = new Date(currentStart);
                    }
                    
                    const diffTime = nextDate - currentDate;
                    const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
                    
                    result.push({
                        startDate: sortedHistory[i].startDate,
                        length: diffDays
                    });
                }
                
                return result;
            };

            // Afficher les durées calculées
            const displayHistory = calculateCycleLengths(history, startDate);

            return (
                <div style={{
                    position: 'fixed',
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0,
                    backgroundColor: 'rgba(0,0,0,0.5)',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    zIndex: 1000,
                    overflow: 'auto',
                    padding: '20px'
                }}>
                    <div style={{
                        backgroundColor: 'white',
                        borderRadius: '12px',
                        padding: '24px',
                        maxWidth: '600px',
                        width: '100%',
                        maxHeight: '90vh',
                        overflow: 'auto',
                        boxShadow: '0 20px 25px -5px rgba(0,0,0,0.1)'
                    }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '24px' }}>
                            <h2 style={{ margin: 0, fontSize: '20px', fontWeight: '600' }}>Configuration du cycle</h2>
                            <button onClick={onClose} style={{ cursor: 'pointer', border: 'none', background: 'none' }}>
                                <XIcon />
                            </button>
                        </div>

                        <div style={{ marginBottom: '20px' }}>
                            <label style={{ display: 'block', marginBottom: '8px', fontSize: '14px', fontWeight: '500' }}>
                                Premier jour des dernières règles (J1 actuel)
                            </label>
                            <input
                                type="date"
                                value={startDate}
                                onChange={(e) => setStartDate(e.target.value)}
                                style={{
                                    width: '100%',
                                    padding: '10px',
                                    borderRadius: '8px',
                                    border: '1px solid #e5e7eb',
                                    fontSize: '14px'
                                }}
                            />
                        </div>

                        <div style={{ marginBottom: '24px' }}>
                            <label style={{ display: 'block', marginBottom: '8px', fontSize: '14px', fontWeight: '500' }}>
                                Durée du cycle actuel (jours)
                            </label>
                            <input
                                type="number"
                                min="21"
                                max="35"
                                value={cycleLength}
                                onChange={(e) => setCycleLength(parseInt(e.target.value))}
                                style={{
                                    width: '100%',
                                    padding: '10px',
                                    borderRadius: '8px',
                                    border: '1px solid #e5e7eb',
                                    fontSize: '14px'
                                }}
                            />
                        </div>

                        {/* Historique des cycles */}
                        <div style={{ marginBottom: '24px', borderTop: '1px solid #e5e7eb', paddingTop: '20px' }}>
                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                                <label style={{ fontSize: '14px', fontWeight: '500' }}>
                                    Historique des cycles passés (J1 uniquement)
                                </label>
                                <button
                                    onClick={addCycleToHistory}
                                    disabled={history.length >= 12}
                                    style={{
                                        padding: '6px 12px',
                                        fontSize: '12px',
                                        backgroundColor: history.length >= 12 ? '#e5e7eb' : '#ec4899',
                                        color: history.length >= 12 ? '#9ca3af' : 'white',
                                        border: 'none',
                                        borderRadius: '6px',
                                        cursor: history.length >= 12 ? 'not-allowed' : 'pointer',
                                        fontWeight: '500'
                                    }}
                                >
                                    + Ajouter J1
                                </button>
                            </div>
                            <p style={{ fontSize: '12px', color: '#6b7280', marginBottom: '12px' }}>
                                Entre les dates de début (J1) de tes cycles passés. Les durées seront calculées automatiquement. (max 12)
                            </p>
                            
                            {history.length > 0 && (
                                <div style={{ display: 'flex', flexDirection: 'column', gap: '8px', maxHeight: '250px', overflow: 'auto' }}>
                                    {history.map((cycle, index) => {
                                        const displayed = displayHistory.find(d => d.startDate === cycle.startDate);
                                        return (
                                            <div key={index} style={{ display: 'flex', gap: '8px', alignItems: 'center' }}>
                                                <input
                                                    type="date"
                                                    value={cycle.startDate}
                                                    onChange={(e) => updateHistoryItem(index, e.target.value)}
                                                    style={{
                                                        flex: 2,
                                                        padding: '8px',
                                                        borderRadius: '6px',
                                                        border: '1px solid #e5e7eb',
                                                        fontSize: '13px'
                                                    }}
                                                    placeholder="Date J1"
                                                />
                                                {displayed && (
                                                    <div style={{
                                                        flex: 1,
                                                        padding: '8px',
                                                        borderRadius: '6px',
                                                        backgroundColor: '#f0fdf4',
                                                        border: '1px solid #86efac',
                                                        fontSize: '13px',
                                                        fontWeight: '500',
                                                        color: '#166534',
                                                        textAlign: 'center'
                                                    }}>
                                                        {displayed.length} jours
                                                    </div>
                                                )}
                                                <button
                                                    onClick={() => removeCycleFromHistory(index)}
                                                    style={{
                                                        padding: '6px',
                                                        backgroundColor: '#fee2e2',
                                                        color: '#ef4444',
                                                        border: 'none',
                                                        borderRadius: '6px',
                                                        cursor: 'pointer',
                                                        fontSize: '12px'
                                                    }}
                                                >
                                                    <TrashIcon />
                                                </button>
                                            </div>
                                        );
                                    })}
                                </div>
                            )}
                            
                            {displayHistory.length > 0 && (
                                <div style={{ 
                                    marginTop: '12px', 
                                    padding: '12px', 
                                    backgroundColor: '#f0f9ff',
                                    borderRadius: '8px',
                                    border: '1px solid #bae6fd'
                                }}>
                                    <p style={{ margin: 0, fontSize: '13px', fontWeight: '500', color: '#0369a1' }}>
                                        📊 Durée moyenne des cycles : {Math.round(
                                            displayHistory.reduce((sum, h) => sum + h.length, cycleLength) / 
                                            (displayHistory.length + 1)
                                        )} jours
                                    </p>
                                </div>
                            )}
                        </div>

                        <div style={{ display: 'flex', gap: '12px', justifyContent: 'flex-end' }}>
                            <button
                                onClick={onClose}
                                style={{
                                    padding: '10px 20px',
                                    borderRadius: '8px',
                                    border: '1px solid #e5e7eb',
                                    background: 'white',
                                    cursor: 'pointer',
                                    fontSize: '14px',
                                    fontWeight: '500'
                                }}
                            >
                                Annuler
                            </button>
                            <button
                                onClick={() => onSave({ 
                                    cycleStartDate: new Date(startDate), 
                                    cycleLength,
                                    cycleHistory: calculateCycleLengths(history.filter(h => h.startDate), startDate)
                                })}
                                style={{
                                    padding: '10px 20px',
                                    borderRadius: '8px',
                                    border: 'none',
                                    background: '#ec4899',
                                    color: 'white',
                                    cursor: 'pointer',
                                    fontSize: '14px',
                                    fontWeight: '500'
                                }}
                            >
                                Enregistrer
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // ===== CREATE EVENT MODAL =====
        const CreateEventModal = ({ date, calendars, onClose, onCreate }) => {
            const [title, setTitle] = useState('');
            const [selectedDate, setSelectedDate] = useState(date);
            const [startTime, setStartTime] = useState('09:00');
            const [duration, setDuration] = useState(60);
            const [selectedCalendar, setSelectedCalendar] = useState(calendars[0]?.id || '');
            const [isCreating, setIsCreating] = useState(false);

            const handleCreate = async () => {
                if (!title.trim()) {
                    alert('Le titre est obligatoire');
                    return;
                }

                setIsCreating(true);
                try {
                    await onCreate({
                        title,
                        date: selectedDate,
                        startTime,
                        duration,
                        calendarId: selectedCalendar
                    });
                    onClose();
                } catch (err) {
                    console.error('Error creating event:', err);
                } finally {
                    setIsCreating(false);
                }
            };

            const getCalendarColor = (calendarId) => {
                const cal = calendars.find(c => c.id === calendarId);
                return cal?.backgroundColor || '#3b82f6';
            };

            // Formater la date pour l'input type="date" (YYYY-MM-DD)
            const formatDateForInput = (d) => {
                const year = d.getFullYear();
                const month = String(d.getMonth() + 1).padStart(2, '0');
                const day = String(d.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            };

            const handleDateChange = (e) => {
                const newDate = new Date(e.target.value + 'T00:00:00');
                setSelectedDate(newDate);
            };

            return (
                <div style={{
                    position: 'fixed',
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0,
                    backgroundColor: 'rgba(0,0,0,0.5)',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    zIndex: 1000
                }}>
                    <div style={{
                        backgroundColor: 'white',
                        borderRadius: '12px',
                        padding: '24px',
                        maxWidth: '500px',
                        width: '90%',
                        boxShadow: '0 20px 25px -5px rgba(0,0,0,0.1)'
                    }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '24px' }}>
                            <h2 style={{ margin: 0, fontSize: '20px', fontWeight: '600' }}>Nouvel événement</h2>
                            <button onClick={onClose} style={{ cursor: 'pointer', border: 'none', background: 'none' }}>
                                <XIcon />
                            </button>
                        </div>

                        <div style={{ marginBottom: '16px' }}>
                            <label style={{ display: 'block', marginBottom: '8px', fontSize: '14px', fontWeight: '500' }}>
                                Titre
                            </label>
                            <input
                                type="text"
                                value={title}
                                onChange={(e) => setTitle(e.target.value)}
                                placeholder="Nom de l'événement"
                                style={{
                                    width: '100%',
                                    padding: '10px',
                                    borderRadius: '8px',
                                    border: '1px solid #e5e7eb',
                                    fontSize: '14px'
                                }}
                            />
                        </div>

                        <div style={{ marginBottom: '16px' }}>
                            <label style={{ display: 'block', marginBottom: '8px', fontSize: '14px', fontWeight: '500' }}>
                                Date
                            </label>
                            <input
                                type="date"
                                value={formatDateForInput(selectedDate)}
                                onChange={handleDateChange}
                                style={{
                                    width: '100%',
                                    padding: '10px',
                                    borderRadius: '8px',
                                    border: '1px solid #e5e7eb',
                                    fontSize: '14px'
                                }}
                            />
                        </div>

                        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '12px', marginBottom: '16px' }}>
                            <div>
                                <label style={{ display: 'block', marginBottom: '8px', fontSize: '14px', fontWeight: '500' }}>
                                    Heure de début
                                </label>
                                <input
                                    type="time"
                                    value={startTime}
                                    onChange={(e) => setStartTime(e.target.value)}
                                    style={{
                                        width: '100%',
                                        padding: '10px',
                                        borderRadius: '8px',
                                        border: '1px solid #e5e7eb',
                                        fontSize: '14px'
                                    }}
                                />
                            </div>
                            <div>
                                <label style={{ display: 'block', marginBottom: '8px', fontSize: '14px', fontWeight: '500' }}>
                                    Durée (minutes)
                                </label>
                                <input
                                    type="number"
                                    min="15"
                                    step="15"
                                    value={duration}
                                    onChange={(e) => setDuration(parseInt(e.target.value))}
                                    style={{
                                        width: '100%',
                                        padding: '10px',
                                        borderRadius: '8px',
                                        border: '1px solid #e5e7eb',
                                        fontSize: '14px'
                                    }}
                                />
                            </div>
                        </div>

                        <div style={{ marginBottom: '24px' }}>
                            <label style={{ display: 'block', marginBottom: '8px', fontSize: '14px', fontWeight: '500' }}>
                                Calendrier
                            </label>
                            <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                                {calendars.map(cal => (
                                    <label
                                        key={cal.id}
                                        style={{
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: '8px',
                                            padding: '10px',
                                            borderRadius: '8px',
                                            border: selectedCalendar === cal.id ? '2px solid #ec4899' : '1px solid #e5e7eb',
                                            cursor: 'pointer',
                                            backgroundColor: selectedCalendar === cal.id ? '#fdf2f8' : 'white'
                                        }}
                                    >
                                        <input
                                            type="radio"
                                            name="calendar"
                                            checked={selectedCalendar === cal.id}
                                            onChange={() => setSelectedCalendar(cal.id)}
                                            style={{ cursor: 'pointer' }}
                                        />
                                        <div
                                            style={{
                                                width: '16px',
                                                height: '16px',
                                                borderRadius: '50%',
                                                backgroundColor: cal.backgroundColor || '#3b82f6'
                                            }}
                                        />
                                        <span style={{ fontSize: '14px', fontWeight: '500' }}>
                                            {cal.summary}
                                        </span>
                                    </label>
                                ))}
                            </div>
                        </div>

                        <div style={{ display: 'flex', gap: '12px', justifyContent: 'flex-end' }}>
                            <button
                                onClick={onClose}
                                disabled={isCreating}
                                style={{
                                    padding: '10px 20px',
                                    borderRadius: '8px',
                                    border: '1px solid #e5e7eb',
                                    background: 'white',
                                    cursor: isCreating ? 'not-allowed' : 'pointer',
                                    fontSize: '14px',
                                    fontWeight: '500'
                                }}
                            >
                                Annuler
                            </button>
                            <button
                                onClick={handleCreate}
                                disabled={isCreating}
                                style={{
                                    padding: '10px 20px',
                                    borderRadius: '8px',
                                    border: 'none',
                                    background: isCreating ? '#9ca3af' : '#ec4899',
                                    color: 'white',
                                    cursor: isCreating ? 'not-allowed' : 'pointer',
                                    fontSize: '14px',
                                    fontWeight: '500',
                                    display: 'flex',
                                    alignItems: 'center',
                                    gap: '8px'
                                }}
                            >
                                {isCreating ? (
                                    <>
                                        <div className="sync-spinner" />
                                        Création...
                                    </>
                                ) : (
                                    <>
                                        <PlusIcon />
                                        Créer
                                    </>
                                )}
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // ===== EDIT EVENT MODAL =====
        // ===== EDIT TASK MODAL =====
        const EditTaskModal = ({ task, onClose, onSync }) => {
            const [title, setTitle] = useState(task.title);
            const [selectedDate, setSelectedDate] = useState(task.date);
            const [selectedTaskList, setSelectedTaskList] = useState(task.taskListId);
            const [taskLists, setTaskLists] = useState([]);
            const [isUpdating, setIsUpdating] = useState(false);
            const [isLoading, setIsLoading] = useState(true);

            useEffect(() => {
                loadTaskLists();
            }, []);

            const loadTaskLists = async () => {
                try {
                    const response = await gapi.client.tasks.tasklists.list();
                    setTaskLists(response.result.items || []);
                    setIsLoading(false);
                } catch (err) {
                    console.error('Error loading task lists:', err);
                    setIsLoading(false);
                }
            };

            const handleUpdate = async () => {
                if (!title.trim()) {
                    alert('Le titre est obligatoire');
                    return;
                }

                setIsUpdating(true);
                try {
                    // Si la liste de tâches a changé, déplacer la tâche
                    if (selectedTaskList !== task.taskListId) {
                        // 1. Créer la tâche dans la nouvelle liste
                        const year = selectedDate.getFullYear();
                        const month = String(selectedDate.getMonth() + 1).padStart(2, '0');
                        const day = String(selectedDate.getDate()).padStart(2, '0');
                        const dueDate = `${year}-${month}-${day}T00:00:00.000Z`;

                        await gapi.client.tasks.tasks.insert({
                            tasklist: selectedTaskList,
                            resource: {
                                title: title,
                                notes: task.description || '',
                                due: dueDate,
                                status: task.status
                            }
                        });

                        // 2. Supprimer l'ancienne tâche
                        await gapi.client.tasks.tasks.delete({
                            tasklist: task.taskListId,
                            task: task.id
                        });
                    } else {
                        // Simplement mettre à jour la tâche
                        const year = selectedDate.getFullYear();
                        const month = String(selectedDate.getMonth() + 1).padStart(2, '0');
                        const day = String(selectedDate.getDate()).padStart(2, '0');
                        const dueDate = `${year}-${month}-${day}T00:00:00.000Z`;

                        await gapi.client.tasks.tasks.patch({
                            tasklist: task.taskListId,
                            task: task.id,
                            title: title,
                            due: dueDate
                        });
                    }

                    // Re-synchroniser pour rafraîchir l'affichage
                    if (onSync) {
                        await onSync();
                    }
                    
                    onClose();
                } catch (err) {
                    console.error('Error updating task:', err);
                    alert('Erreur lors de la mise à jour de la tâche');
                } finally {
                    setIsUpdating(false);
                }
            };

            const handleDelete = async () => {
                if (!confirm('Êtes-vous sûr de vouloir supprimer cette tâche ?')) {
                    return;
                }

                try {
                    await gapi.client.tasks.tasks.delete({
                        tasklist: task.taskListId,
                        task: task.id
                    });

                    // Re-synchroniser pour rafraîchir l'affichage
                    if (onSync) {
                        await onSync();
                    }
                    
                    onClose();
                } catch (err) {
                    console.error('Error deleting task:', err);
                    alert('Erreur lors de la suppression de la tâche');
                }
            };

            const formatDateForInput = (d) => {
                const year = d.getFullYear();
                const month = String(d.getMonth() + 1).padStart(2, '0');
                const day = String(d.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            };

            const handleDateChange = (e) => {
                const newDate = new Date(e.target.value + 'T00:00:00');
                setSelectedDate(newDate);
            };

            return (
                <div style={{
                    position: 'fixed',
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0,
                    backgroundColor: 'rgba(0,0,0,0.5)',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    zIndex: 1000
                }}>
                    <div style={{
                        backgroundColor: 'white',
                        borderRadius: '12px',
                        padding: '24px',
                        maxWidth: '500px',
                        width: '90%',
                        boxShadow: '0 20px 25px -5px rgba(0,0,0,0.1)'
                    }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '24px' }}>
                            <h2 style={{ margin: 0, fontSize: '20px', fontWeight: '600' }}>Modifier la tâche</h2>
                            <button onClick={onClose} style={{ cursor: 'pointer', border: 'none', background: 'none' }}>
                                <XIcon />
                            </button>
                        </div>

                        <div style={{ marginBottom: '16px' }}>
                            <label style={{ display: 'block', marginBottom: '8px', fontSize: '14px', fontWeight: '500' }}>
                                Titre
                            </label>
                            <input
                                type="text"
                                value={title}
                                onChange={(e) => setTitle(e.target.value)}
                                placeholder="Nom de la tâche"
                                style={{
                                    width: '100%',
                                    padding: '10px',
                                    borderRadius: '8px',
                                    border: '1px solid #e5e7eb',
                                    fontSize: '14px'
                                }}
                            />
                        </div>

                        <div style={{ marginBottom: '16px' }}>
                            <label style={{ display: 'block', marginBottom: '8px', fontSize: '14px', fontWeight: '500' }}>
                                Date d'échéance
                            </label>
                            <input
                                type="date"
                                value={formatDateForInput(selectedDate)}
                                onChange={handleDateChange}
                                style={{
                                    width: '100%',
                                    padding: '10px',
                                    borderRadius: '8px',
                                    border: '1px solid #e5e7eb',
                                    fontSize: '14px'
                                }}
                            />
                        </div>

                        <div style={{ marginBottom: '16px' }}>
                            <label style={{ display: 'block', marginBottom: '8px', fontSize: '14px', fontWeight: '500' }}>
                                Statut
                            </label>
                            <div style={{
                                padding: '10px',
                                borderRadius: '8px',
                                backgroundColor: task.status === 'completed' ? '#dcfce7' : '#fef3c7',
                                color: task.status === 'completed' ? '#166534' : '#854d0e',
                                fontSize: '14px',
                                fontWeight: '500'
                            }}>
                                {task.status === 'completed' ? '✓ Complétée' : '○ À faire'}
                            </div>
                        </div>

                        {!isLoading && taskLists.length > 0 && (
                            <div style={{ marginBottom: '24px' }}>
                                <label style={{ display: 'block', marginBottom: '8px', fontSize: '14px', fontWeight: '500' }}>
                                    Liste de tâches
                                </label>
                                <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                                    {taskLists.map(list => (
                                        <label
                                            key={list.id}
                                            style={{
                                                display: 'flex',
                                                alignItems: 'center',
                                                gap: '8px',
                                                padding: '10px',
                                                borderRadius: '8px',
                                                border: selectedTaskList === list.id ? '2px solid #F59E0B' : '1px solid #e5e7eb',
                                                cursor: 'pointer',
                                                backgroundColor: selectedTaskList === list.id ? '#fffbeb' : 'white'
                                            }}
                                        >
                                            <input
                                                type="radio"
                                                name="tasklist"
                                                checked={selectedTaskList === list.id}
                                                onChange={() => setSelectedTaskList(list.id)}
                                                style={{ cursor: 'pointer' }}
                                            />
                                            <span style={{ fontSize: '14px', fontWeight: '500' }}>
                                                {list.title}
                                            </span>
                                        </label>
                                    ))}
                                </div>
                            </div>
                        )}

                        <div style={{ display: 'flex', gap: '12px', justifyContent: 'space-between' }}>
                            <button
                                onClick={handleDelete}
                                style={{
                                    padding: '10px 20px',
                                    borderRadius: '8px',
                                    border: 'none',
                                    backgroundColor: '#ef4444',
                                    color: 'white',
                                    fontSize: '14px',
                                    fontWeight: '600',
                                    cursor: 'pointer'
                                }}
                            >
                                🗑️ Supprimer
                            </button>
                            <div style={{ display: 'flex', gap: '12px' }}>
                                <button
                                    onClick={onClose}
                                    style={{
                                        padding: '10px 20px',
                                        borderRadius: '8px',
                                        border: '1px solid #e5e7eb',
                                        backgroundColor: 'white',
                                        color: '#6b7280',
                                        fontSize: '14px',
                                        fontWeight: '600',
                                        cursor: 'pointer'
                                    }}
                                >
                                    Annuler
                                </button>
                                <button
                                    onClick={handleUpdate}
                                    disabled={isUpdating}
                                    style={{
                                        padding: '10px 20px',
                                        borderRadius: '8px',
                                        border: 'none',
                                        backgroundColor: isUpdating ? '#9ca3af' : '#F59E0B',
                                        color: 'white',
                                        fontSize: '14px',
                                        fontWeight: '600',
                                        cursor: isUpdating ? 'not-allowed' : 'pointer'
                                    }}
                                >
                                    {isUpdating ? 'Mise à jour...' : 'Enregistrer'}
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const EditEventModal = ({ event, calendars, onClose, onUpdate, onDelete }) => {
            const [title, setTitle] = useState(event.title);
            const [selectedDate, setSelectedDate] = useState(event.date);
            const [startTime, setStartTime] = useState(event.startTime);
            const [duration, setDuration] = useState(event.duration);
            const [selectedCalendar, setSelectedCalendar] = useState(event.calendarId);
            const [isUpdating, setIsUpdating] = useState(false);

            const handleUpdate = async () => {
                if (!title.trim()) {
                    alert('Le titre est obligatoire');
                    return;
                }

                setIsUpdating(true);
                try {
                    await onUpdate({
                        eventId: event.id,
                        title,
                        date: selectedDate,
                        startTime,
                        duration,
                        calendarId: selectedCalendar
                    });
                    onClose();
                } catch (err) {
                    console.error('Error updating event:', err);
                } finally {
                    setIsUpdating(false);
                }
            };

            const handleDelete = async () => {
                try {
                    await onDelete({
                        eventId: event.id,
                        calendarId: event.calendarId
                    });
                    onClose();
                } catch (err) {
                    console.error('Error deleting event:', err);
                }
            };

            // Formater la date pour l'input type="date" (YYYY-MM-DD)
            const formatDateForInput = (d) => {
                const year = d.getFullYear();
                const month = String(d.getMonth() + 1).padStart(2, '0');
                const day = String(d.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            };

            const handleDateChange = (e) => {
                const newDate = new Date(e.target.value + 'T00:00:00');
                setSelectedDate(newDate);
            };

            return (
                <div style={{
                    position: 'fixed',
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0,
                    backgroundColor: 'rgba(0,0,0,0.5)',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    zIndex: 1000
                }}>
                    <div style={{
                        backgroundColor: 'white',
                        borderRadius: '12px',
                        padding: '24px',
                        maxWidth: '500px',
                        width: '90%',
                        boxShadow: '0 20px 25px -5px rgba(0,0,0,0.1)'
                    }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '24px' }}>
                            <h2 style={{ margin: 0, fontSize: '20px', fontWeight: '600' }}>Modifier l'événement</h2>
                            <button onClick={onClose} style={{ cursor: 'pointer', border: 'none', background: 'none' }}>
                                <XIcon />
                            </button>
                        </div>

                        <div style={{ marginBottom: '16px' }}>
                            <label style={{ display: 'block', marginBottom: '8px', fontSize: '14px', fontWeight: '500' }}>
                                Titre
                            </label>
                            <input
                                type="text"
                                value={title}
                                onChange={(e) => setTitle(e.target.value)}
                                placeholder="Nom de l'événement"
                                style={{
                                    width: '100%',
                                    padding: '10px',
                                    borderRadius: '8px',
                                    border: '1px solid #e5e7eb',
                                    fontSize: '14px'
                                }}
                            />
                        </div>

                        <div style={{ marginBottom: '16px' }}>
                            <label style={{ display: 'block', marginBottom: '8px', fontSize: '14px', fontWeight: '500' }}>
                                Date
                            </label>
                            <input
                                type="date"
                                value={formatDateForInput(selectedDate)}
                                onChange={handleDateChange}
                                style={{
                                    width: '100%',
                                    padding: '10px',
                                    borderRadius: '8px',
                                    border: '1px solid #e5e7eb',
                                    fontSize: '14px'
                                }}
                            />
                        </div>

                        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '12px', marginBottom: '16px' }}>
                            <div>
                                <label style={{ display: 'block', marginBottom: '8px', fontSize: '14px', fontWeight: '500' }}>
                                    Heure de début
                                </label>
                                <input
                                    type="time"
                                    value={startTime}
                                    onChange={(e) => setStartTime(e.target.value)}
                                    style={{
                                        width: '100%',
                                        padding: '10px',
                                        borderRadius: '8px',
                                        border: '1px solid #e5e7eb',
                                        fontSize: '14px'
                                    }}
                                />
                            </div>
                            <div>
                                <label style={{ display: 'block', marginBottom: '8px', fontSize: '14px', fontWeight: '500' }}>
                                    Durée (minutes)
                                </label>
                                <input
                                    type="number"
                                    min="15"
                                    step="15"
                                    value={duration}
                                    onChange={(e) => setDuration(parseInt(e.target.value))}
                                    style={{
                                        width: '100%',
                                        padding: '10px',
                                        borderRadius: '8px',
                                        border: '1px solid #e5e7eb',
                                        fontSize: '14px'
                                    }}
                                />
                            </div>
                        </div>

                        <div style={{ marginBottom: '24px' }}>
                            <label style={{ display: 'block', marginBottom: '8px', fontSize: '14px', fontWeight: '500' }}>
                                Calendrier
                            </label>
                            <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                                {calendars.map(cal => (
                                    <label
                                        key={cal.id}
                                        style={{
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: '8px',
                                            padding: '10px',
                                            borderRadius: '8px',
                                            border: selectedCalendar === cal.id ? '2px solid #ec4899' : '1px solid #e5e7eb',
                                            cursor: 'pointer',
                                            backgroundColor: selectedCalendar === cal.id ? '#fdf2f8' : 'white'
                                        }}
                                    >
                                        <input
                                            type="radio"
                                            name="calendar"
                                            checked={selectedCalendar === cal.id}
                                            onChange={() => setSelectedCalendar(cal.id)}
                                            style={{ cursor: 'pointer' }}
                                        />
                                        <div
                                            style={{
                                                width: '16px',
                                                height: '16px',
                                                borderRadius: '50%',
                                                backgroundColor: cal.backgroundColor || '#3b82f6'
                                            }}
                                        />
                                        <span style={{ fontSize: '14px', fontWeight: '500' }}>
                                            {cal.summary}
                                        </span>
                                    </label>
                                ))}
                            </div>
                        </div>

                        <div style={{ display: 'flex', gap: '12px', justifyContent: 'space-between' }}>
                            <button
                                onClick={handleDelete}
                                disabled={isUpdating}
                                style={{
                                    padding: '10px 20px',
                                    borderRadius: '8px',
                                    border: 'none',
                                    background: '#ef4444',
                                    color: 'white',
                                    cursor: isUpdating ? 'not-allowed' : 'pointer',
                                    fontSize: '14px',
                                    fontWeight: '500',
                                    display: 'flex',
                                    alignItems: 'center',
                                    gap: '8px'
                                }}
                            >
                                <TrashIcon />
                                Supprimer
                            </button>
                            <div style={{ display: 'flex', gap: '12px' }}>
                                <button
                                    onClick={onClose}
                                    disabled={isUpdating}
                                    style={{
                                        padding: '10px 20px',
                                        borderRadius: '8px',
                                        border: '1px solid #e5e7eb',
                                        background: 'white',
                                        cursor: isUpdating ? 'not-allowed' : 'pointer',
                                        fontSize: '14px',
                                        fontWeight: '500'
                                    }}
                                >
                                    Annuler
                                </button>
                                <button
                                    onClick={handleUpdate}
                                    disabled={isUpdating}
                                    style={{
                                        padding: '10px 20px',
                                        borderRadius: '8px',
                                        border: 'none',
                                        background: isUpdating ? '#9ca3af' : '#ec4899',
                                        color: 'white',
                                        cursor: isUpdating ? 'not-allowed' : 'pointer',
                                        fontSize: '14px',
                                        fontWeight: '500',
                                        display: 'flex',
                                        alignItems: 'center',
                                        gap: '8px'
                                    }}
                                >
                                    {isUpdating ? (
                                        <>
                                            <div className="sync-spinner" />
                                            Modification...
                                        </>
                                    ) : (
                                        <>
                                            <EditIcon />
                                            Modifier
                                        </>
                                    )}
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // ===== COMPOSANT PRINCIPAL =====
        function LunariumPlanner() {
            const [activities, setActivities] = useState({});
            const [toast, setToast] = useState(null);
            const [showConfigModal, setShowConfigModal] = useState(false);
            const [selectedCircleDay, setSelectedCircleDay] = useState(null);
            const [selectedDate, setSelectedDate] = useState(null);
            const [showCreateEventModal, setShowCreateEventModal] = useState(false);
            const [createEventDate, setCreateEventDate] = useState(null);
            const [googleCalendars, setGoogleCalendars] = useState([]);
            const [showEditEventModal, setShowEditEventModal] = useState(false);
            const [editingEvent, setEditingEvent] = useState(null);
            const [sunDataLoaded, setSunDataLoaded] = useState(false);
            const [sunData, setSunData] = useState({});
            const [currentView, setCurrentView] = useState('cycle'); // 'cycle' ou 'month'
            const [currentMonth, setCurrentMonth] = useState(new Date());
            const [syncFunction, setSyncFunction] = useState(null);
            const [showTasksSidebar, setShowTasksSidebar] = useState(false);
            
            const [cycleHistory, setCycleHistory] = useState(() => {
                const saved = localStorage.getItem('cycleHistory');
                if (saved) {
                    try {
                        return JSON.parse(saved);
                    } catch (e) {
                        return [];
                    }
                }
                return [];
            });

            const [cycleConfig, setCycleConfig] = useState(() => {
                const saved = localStorage.getItem('cycleConfig');
                if (saved) {
                    try {
                        const parsed = JSON.parse(saved);
                        
                        // Parser la date en temps local (pas UTC)
                        let startDate;
                        if (typeof parsed.cycleStartDate === 'string') {
                            // Si c'est au format YYYY-MM-DD, créer une date locale
                            const parts = parsed.cycleStartDate.split('T')[0].split('-');
                            if (parts.length === 3) {
                                startDate = new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
                            } else {
                                startDate = new Date(parsed.cycleStartDate);
                            }
                        } else {
                            startDate = new Date(parsed.cycleStartDate);
                        }
                        
                        // Vérifier que la date est valide
                        if (isNaN(startDate.getTime())) {
                            console.error('Invalid date in localStorage, using today');
                            return {
                                cycleLength: 28,
                                cycleStartDate: new Date()
                            };
                        }
                        return {
                            cycleLength: parsed.cycleLength || 28,
                            cycleStartDate: startDate
                        };
                    } catch (e) {
                        console.error('Error parsing cycleConfig:', e);
                        return {
                            cycleLength: 28,
                            cycleStartDate: new Date()
                        };
                    }
                }
                return {
                    cycleLength: 28,
                    cycleStartDate: new Date()
                };
            });

            useEffect(() => {
                if (cycleConfig.cycleStartDate && !isNaN(cycleConfig.cycleStartDate.getTime())) {
                    // Sauvegarder en format local YYYY-MM-DD pour éviter les problèmes de fuseau horaire
                    const year = cycleConfig.cycleStartDate.getFullYear();
                    const month = String(cycleConfig.cycleStartDate.getMonth() + 1).padStart(2, '0');
                    const day = String(cycleConfig.cycleStartDate.getDate()).padStart(2, '0');
                    const dateString = `${year}-${month}-${day}`;
                    
                    localStorage.setItem('cycleConfig', JSON.stringify({
                        cycleLength: cycleConfig.cycleLength,
                        cycleStartDate: dateString
                    }));
                }
            }, [cycleConfig]);

            useEffect(() => {
                localStorage.setItem('cycleHistory', JSON.stringify(cycleHistory));
            }, [cycleHistory]);

            // Auto-update à minuit - Force le re-render du cycle
            useEffect(() => {
                const checkMidnight = () => {
                    const now = new Date();
                    const tomorrow = new Date(now);
                    tomorrow.setHours(24, 0, 0, 0);
                    const msUntilMidnight = tomorrow - now;
                    
                    // Programmer un timeout jusqu'à minuit
                    const timeoutId = setTimeout(() => {
                        console.log('Midnight! Updating cycle view...');
                        // Force un re-render en mettant à jour un état
                        setActivities(prev => ({...prev}));
                        // Re-programmer pour la prochaine minuit
                        checkMidnight();
                    }, msUntilMidnight);
                    
                    return () => clearTimeout(timeoutId);
                };
                
                // Démarrer la vérification
                const cleanup = checkMidnight();
                return cleanup;
            }, []);

            const getCycleDay = (date) => {
                if (!cycleConfig.cycleStartDate || isNaN(cycleConfig.cycleStartDate.getTime())) {
                    return 1; // Retourner jour 1 par défaut si date invalide
                }
                const diffTime = date - cycleConfig.cycleStartDate;
                const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
                const cycleDay = ((diffDays % cycleConfig.cycleLength) + cycleConfig.cycleLength) % cycleConfig.cycleLength;
                return cycleDay === 0 ? cycleConfig.cycleLength : cycleDay;
            };

            const getDateForCycleDay = (cycleDay) => {
                try {
                    const currentCycleDay = getCycleDay(new Date());
                    const daysToAdd = cycleDay - currentCycleDay;
                    const date = new Date();
                    date.setDate(date.getDate() + daysToAdd);
                    
                    // Vérifier que la date calculée est valide
                    if (isNaN(date.getTime())) {
                        console.error('Invalid date calculated for cycle day:', cycleDay);
                        return new Date(); // Retourner aujourd'hui par défaut
                    }
                    
                    return date;
                } catch (e) {
                    console.error('Error in getDateForCycleDay:', e);
                    return new Date();
                }
            };

            const formatDate = (date) => {
                if (!date || isNaN(date.getTime())) {
                    const today = new Date();
                    const year = today.getFullYear();
                    const month = String(today.getMonth() + 1).padStart(2, '0');
                    const day = String(today.getDate()).padStart(2, '0');
                    return `${year}-${month}-${day}`;
                }
                // Utiliser la date locale au lieu d'UTC
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            };

            const getGoogleColor = (colorId) => {
                const colors = {
                    '1': '#7986cb', '2': '#33b679', '3': '#8e24aa', '4': '#e67c73',
                    '5': '#f6c026', '6': '#f5511d', '7': '#039be5', '8': '#616161',
                    '9': '#3f51b5', '10': '#0b8043', '11': '#d60000'
                };
                return colors[colorId] || '#3b82f6';
            };

            const showToast = (message, type = 'info') => {
                setToast({ message, type });
                setTimeout(() => setToast(null), 3000);
            };

            // Calculer la longueur moyenne du cycle basée sur l'historique
            const getAverageCycleLength = () => {
                if (cycleHistory.length === 0) {
                    return cycleConfig.cycleLength;
                }
                const sum = cycleHistory.reduce((acc, cycle) => acc + cycle.length, cycleConfig.cycleLength);
                return Math.round(sum / (cycleHistory.length + 1));
            };

            // Obtenir le jour du cycle pour une date donnée basé sur la moyenne
            const getCycleDayForDate = (date) => {
                const avgLength = getAverageCycleLength();
                const diffTime = date - cycleConfig.cycleStartDate;
                const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
                const cycleDay = ((diffDays % avgLength) + avgLength) % avgLength;
                return cycleDay === 0 ? avgLength : cycleDay;
            };

            // Obtenir les infos de phase pour une date donnée
            const getPhaseForDate = (date) => {
                const cycleDay = getCycleDayForDate(date);
                const avgLength = getAverageCycleLength();
                return getPhaseInfo(cycleDay, avgLength);
            };

            // Pré-charger les données du soleil pour tous les jours du cycle
            useEffect(() => {
                const loadSunData = async () => {
                    const newSunData = {};
                    const promises = [];
                    
                    for (let day = 1; day <= cycleConfig.cycleLength; day++) {
                        const date = getDateForCycleDay(day);
                        const dateStr = date.toISOString().split('T')[0];
                        
                        promises.push(
                            fetchSunTimes(date).then(data => {
                                newSunData[dateStr] = data;
                            })
                        );
                    }
                    
                    await Promise.all(promises);
                    setSunData(newSunData);
                    setSunDataLoaded(true);
                };
                
                loadSunData();
            }, [cycleConfig.cycleStartDate, cycleConfig.cycleLength]);
            
            // Fonction pour obtenir les données du soleil pour une date donnée
            const getSunTimes = (date) => {
                const dateStr = date.toISOString().split('T')[0];
                return sunData[dateStr] || { sunrise: '...', sunset: '...', sunriseDecimal: 7.5, sunsetDecimal: 17 };
            };

            const createEvent = async ({ title, date, startTime, duration, calendarId }) => {
                if (typeof gapi === 'undefined' || !gapi.client) {
                    showToast('Google API non disponible', 'error');
                    return;
                }

                try {
                    // Construire la date/heure de début
                    const [hours, minutes] = startTime.split(':').map(Number);
                    const startDateTime = new Date(date);
                    startDateTime.setHours(hours, minutes, 0, 0);
                    
                    // Construire la date/heure de fin
                    const endDateTime = new Date(startDateTime);
                    endDateTime.setMinutes(endDateTime.getMinutes() + duration);

                    // Créer l'événement dans Google Calendar
                    const event = {
                        summary: title,
                        start: {
                            dateTime: startDateTime.toISOString(),
                            timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
                        },
                        end: {
                            dateTime: endDateTime.toISOString(),
                            timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
                        }
                    };

                    console.log('Creating event:', event);
                    
                    const response = await gapi.client.calendar.events.insert({
                        calendarId: calendarId,
                        resource: event
                    });

                    console.log('Event created:', response);
                    showToast('Événement créé avec succès ✓', 'success');
                    
                    // Resynchroniser pour afficher le nouvel événement
                    const savedCalendars = localStorage.getItem('selectedCalendars');
                    if (savedCalendars) {
                        const calendars = JSON.parse(savedCalendars);
                        // Attendre un peu pour que Google Calendar soit à jour
                        setTimeout(() => {
                            console.log('Resyncing after event creation...');
                            resyncCalendars(calendars);
                        }, 500);
                    }
                } catch (err) {
                    console.error('Error creating event:', err);
                    showToast('Erreur lors de la création de l\'événement', 'error');
                    throw err;
                }
            };

            const updateEvent = async ({ eventId, title, date, startTime, duration, calendarId }) => {
                if (typeof gapi === 'undefined' || !gapi.client) {
                    showToast('Google API non disponible', 'error');
                    return;
                }

                try {
                    // Construire la date/heure de début
                    const [hours, minutes] = startTime.split(':').map(Number);
                    const startDateTime = new Date(date);
                    startDateTime.setHours(hours, minutes, 0, 0);
                    
                    // Construire la date/heure de fin
                    const endDateTime = new Date(startDateTime);
                    endDateTime.setMinutes(endDateTime.getMinutes() + duration);

                    // Mettre à jour l'événement dans Google Calendar
                    const event = {
                        summary: title,
                        start: {
                            dateTime: startDateTime.toISOString(),
                            timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
                        },
                        end: {
                            dateTime: endDateTime.toISOString(),
                            timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
                        }
                    };

                    console.log('Updating event:', eventId, event);
                    
                    const response = await gapi.client.calendar.events.patch({
                        calendarId: calendarId,
                        eventId: eventId,
                        resource: event
                    });

                    console.log('Event updated:', response);
                    showToast('Événement modifié avec succès ✓', 'success');
                    
                    // Resynchroniser pour afficher les modifications
                    const savedCalendars = localStorage.getItem('selectedCalendars');
                    if (savedCalendars) {
                        const calendars = JSON.parse(savedCalendars);
                        setTimeout(() => {
                            console.log('Resyncing after event update...');
                            resyncCalendars(calendars);
                        }, 500);
                    }
                } catch (err) {
                    console.error('Error updating event:', err);
                    showToast('Erreur lors de la modification de l\'événement', 'error');
                    throw err;
                }
            };

            const deleteEvent = async ({ eventId, calendarId }) => {
                if (typeof gapi === 'undefined' || !gapi.client) {
                    showToast('Google API non disponible', 'error');
                    return;
                }

                if (!confirm('Êtes-vous sûr de vouloir supprimer cet événement ?')) {
                    return;
                }

                try {
                    console.log('Deleting event:', eventId, 'from calendar:', calendarId);
                    
                    await gapi.client.calendar.events.delete({
                        calendarId: calendarId,
                        eventId: eventId
                    });

                    console.log('Event deleted');
                    showToast('Événement supprimé ✓', 'success');
                    
                    // Resynchroniser pour retirer l'événement de l'affichage
                    const savedCalendars = localStorage.getItem('selectedCalendars');
                    if (savedCalendars) {
                        const calendars = JSON.parse(savedCalendars);
                        setTimeout(() => {
                            console.log('Resyncing after event deletion...');
                            resyncCalendars(calendars);
                        }, 500);
                    }
                } catch (err) {
                    console.error('Error deleting event:', err);
                    showToast('Erreur lors de la suppression de l\'événement', 'error');
                    throw err;
                }
            };

            const resyncCalendars = async (calendarsToSync) => {
                if (typeof gapi === 'undefined' || !gapi.client) {
                    showToast('Google API non disponible', 'error');
                    return;
                }
                
                try {
                    const now = new Date();
                    const sixMonthsAgo = new Date(now.getFullYear(), now.getMonth() - 6, 1);
                    const sixMonthsAhead = new Date(now.getFullYear(), now.getMonth() + 6, 31);
                    
                    // Récupérer les infos complètes des calendriers pour les couleurs
                    const calendarMap = {};
                    for (const cal of googleCalendars) {
                        if (calendarsToSync.includes(cal.id)) {
                            calendarMap[cal.id] = cal.backgroundColor || '#3b82f6';
                        }
                    }
                    
                    const allEvents = [];
                    for (const calendarId of calendarsToSync) {
                        const response = await gapi.client.calendar.events.list({
                            calendarId: calendarId,
                            timeMin: sixMonthsAgo.toISOString(),
                            timeMax: sixMonthsAhead.toISOString(),
                            singleEvents: true,
                            orderBy: 'startTime',
                        });
                        
                        const events = response.result.items || [];
                        allEvents.push(...events.map(e => ({ ...e, calendarId })));
                    }
                    
                    // Transformer les événements
                    const newActivities = {};
                    allEvents.forEach(event => {
                        if (!event.start || !event.start.dateTime) return;
                        
                        const startDate = new Date(event.start.dateTime);
                        const endDate = new Date(event.end.dateTime);
                        
                        const year = startDate.getFullYear();
                        const month = String(startDate.getMonth() + 1).padStart(2, '0');
                        const day = String(startDate.getDate()).padStart(2, '0');
                        const dateKey = `${year}-${month}-${day}`;
                        
                        if (!newActivities[dateKey]) {
                            newActivities[dateKey] = [];
                        }
                        
                        // Déterminer la couleur: backgroundColor > colorId > calendar color
                        let eventColor = '#3b82f6'; // Couleur par défaut
                        if (event.backgroundColor) {
                            eventColor = event.backgroundColor;
                        } else if (event.colorId) {
                            eventColor = getGoogleColor(event.colorId);
                        } else if (calendarMap && calendarMap[event.calendarId]) {
                            eventColor = calendarMap[event.calendarId];
                        }
                        
                        newActivities[dateKey].push({
                            id: event.id,
                            title: event.summary || 'Sans titre',
                            startTime: startDate.toTimeString().slice(0, 5),
                            duration: Math.round((endDate - startDate) / (1000 * 60)),
                            color: eventColor,
                            description: event.description || '',
                            calendarId: event.calendarId,
                            date: startDate
                        });
                    });
                    
                    // Trier tous les événements de chaque jour par ordre chronologique
                    Object.keys(newActivities).forEach(dateKey => {
                        newActivities[dateKey].sort((a, b) => {
                            const timeA = a.startTime.split(':').map(Number);
                            const timeB = b.startTime.split(':').map(Number);
                            return (timeA[0] * 60 + timeA[1]) - (timeB[0] * 60 + timeB[1]);
                        });
                    });
                    
                    setActivities(newActivities);
                } catch (err) {
                    console.error('Error syncing:', err);
                    showToast('Erreur de synchronisation', 'error');
                }
            };

            const renderCircleView = () => {
                // Calculer la largeur disponible en tenant compte des sidebars
                const isMobile = window.innerWidth < 768;
                const leftSidebarWidth = isMobile ? 0 : 280;
                const rightSidebarWidth = (showTasksSidebar && !isMobile) ? 350 : 0;
                const totalSidebarWidth = leftSidebarWidth + rightSidebarWidth;
                const availableWidth = window.innerWidth - totalSidebarWidth - 100;
                const svgSize = Math.min(availableWidth, 800);
                const centerX = svgSize / 2;
                const centerY = svgSize / 2;
                const outerRadius = svgSize * 0.38;
                const innerRadius = svgSize * 0.31;
                const middleRadius = (outerRadius + innerRadius) / 2;
                const anglePerDay = (2 * Math.PI) / cycleConfig.cycleLength;
                
                const today = new Date();
                const currentCycleDay = getCycleDay(today);
                const displayDay = selectedCircleDay || currentCycleDay;
                
                // Rotation pour mettre le jour actuel en haut
                const rotationOffset = -((currentCycleDay - 0.5) * anglePerDay);
                const rotationDegrees = rotationOffset * 180 / Math.PI;

                return (
                    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', padding: '20px' }}>
                        <svg width={svgSize} height={svgSize} viewBox={`0 0 ${svgSize} ${svgSize}`}>
                            {/* Flèche fixe en haut */}
                            <polygon
                                points={`${centerX},${centerY - outerRadius - 10} ${centerX - 12},${centerY - outerRadius - 25} ${centerX + 12},${centerY - outerRadius - 25}`}
                                fill="#4b5563"
                                stroke="#374151"
                                strokeWidth="1.5"
                                style={{ filter: 'drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3))' }}
                            />
                            
                            {/* Segments rotatifs */}
                            <g transform={`rotate(${rotationDegrees} ${centerX} ${centerY})`}>
                            {Array.from({ length: cycleConfig.cycleLength }, (_, i) => {
                                const cycleDay = i + 1;
                                const phaseInfo = getPhaseInfo(cycleDay, cycleConfig.cycleLength);
                                const date = getDateForCycleDay(cycleDay);
                                const isToday = cycleDay === currentCycleDay;
                                const isSelected = cycleDay === displayDay;
                                
                                const startAngle = -Math.PI / 2 + i * anglePerDay;
                                const endAngle = startAngle + anglePerDay;
                                
                                const x1 = centerX + outerRadius * Math.cos(startAngle);
                                const y1 = centerY + outerRadius * Math.sin(startAngle);
                                const x2 = centerX + outerRadius * Math.cos(endAngle);
                                const y2 = centerY + outerRadius * Math.sin(endAngle);
                                const x3 = centerX + innerRadius * Math.cos(endAngle);
                                const y3 = centerY + innerRadius * Math.sin(endAngle);
                                const x4 = centerX + innerRadius * Math.cos(startAngle);
                                const y4 = centerY + innerRadius * Math.sin(startAngle);
                                
                                const pathData = `M ${x1} ${y1} A ${outerRadius} ${outerRadius} 0 0 1 ${x2} ${y2} L ${x3} ${y3} A ${innerRadius} ${innerRadius} 0 0 0 ${x4} ${y4} Z`;
                                
                                return (
                                    <path
                                        key={cycleDay}
                                        d={pathData}
                                        fill={phaseInfo.color}
                                        stroke={isToday ? '#2563eb' : (isSelected ? '#374151' : phaseInfo.border)}
                                        strokeWidth={isToday ? 4 : (isSelected ? 3 : 1)}
                                        className="cycle-segment"
                                        onClick={() => {
                                            setSelectedCircleDay(cycleDay);
                                            setSelectedDate(date);
                                        }}
                                    />
                                );
                            })}
                            </g>
                            
                            {/* Textes fixes */}
                            {Array.from({ length: cycleConfig.cycleLength }, (_, i) => {
                                const cycleDay = i + 1;
                                const phaseInfo = getPhaseInfo(cycleDay, cycleConfig.cycleLength);
                                const date = getDateForCycleDay(cycleDay);
                                const moonInfo = getMoonInfo(date);
                                
                                const baseAngle = -Math.PI / 2 + i * anglePerDay + anglePerDay / 2;
                                const adjustedAngle = baseAngle + rotationOffset;
                                
                                const textX = centerX + middleRadius * Math.cos(adjustedAngle);
                                const textY = centerY + middleRadius * Math.sin(adjustedAngle);
                                
                                return (
                                    <g key={`text-${cycleDay}`}>
                                        <text
                                            x={textX}
                                            y={textY - 10}
                                            textAnchor="middle"
                                            dominantBaseline="middle"
                                            style={{ fontSize: '10px', pointerEvents: 'none' }}
                                        >
                                            {moonInfo.emoji}
                                        </text>
                                        <text
                                            x={textX}
                                            y={textY + 1}
                                            textAnchor="middle"
                                            dominantBaseline="middle"
                                            style={{ fontSize: '9px', fontWeight: '700', fill: phaseInfo.text, pointerEvents: 'none' }}
                                        >
                                            J{cycleDay}
                                        </text>
                                        <text
                                            x={textX}
                                            y={textY + 11}
                                            textAnchor="middle"
                                            dominantBaseline="middle"
                                            style={{ fontSize: '8px', fontWeight: '500', fill: phaseInfo.text, pointerEvents: 'none' }}
                                        >
                                            {date.getDate()}/{date.getMonth() + 1}
                                        </text>
                                    </g>
                                );
                            })}
                            
                            {/* Centre blanc */}
                            <circle
                                cx={centerX}
                                cy={centerY}
                                r={innerRadius * 0.95}
                                fill="white"
                                stroke="#e5e7eb"
                                strokeWidth="2"
                            />
                            
                            {/* Contenu central */}
                            <foreignObject
                                x={centerX - innerRadius * 0.85}
                                y={centerY - innerRadius * 0.85}
                                width={innerRadius * 1.7}
                                height={innerRadius * 1.7}
                            >
                                <div style={{
                                    width: '100%',
                                    height: '100%',
                                    display: 'flex',
                                    flexDirection: 'column',
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    padding: '16px',
                                    overflow: 'auto'
                                }}>
                                    {(() => {
                                        const date = getDateForCycleDay(displayDay);
                                        const phaseInfo = getPhaseInfo(displayDay, cycleConfig.cycleLength);
                                        const sunTimes = getSunTimes(date);
                                        const moonInfo = getMoonInfo(date);
                                        const dayActivities = activities[formatDate(date)] || [];

                                        return (
                                            <>
                                                <div style={{ textAlign: 'center', marginBottom: window.innerWidth < 768 ? '8px' : '12px' }}>
                                                    <div style={{ fontSize: window.innerWidth < 768 ? '16px' : '18px', fontWeight: '700', color: phaseInfo.text, marginBottom: '4px' }}>
                                                        J{displayDay} • {phaseInfo.shortName}
                                                    </div>
                                                    <div style={{ fontSize: window.innerWidth < 768 ? '10px' : '11px', color: '#6b7280' }}>
                                                        {date.toLocaleDateString('fr-FR', { weekday: 'short', day: 'numeric', month: 'short' })}
                                                    </div>
                                                    <div style={{ fontSize: window.innerWidth < 768 ? '9px' : '10px', color: '#9ca3af', marginTop: '4px' }}>
                                                        {moonInfo.emoji} {moonInfo.name}
                                                    </div>
                                                    <div style={{ fontSize: window.innerWidth < 768 ? '8px' : '9px', color: '#9ca3af', marginTop: '2px' }}>
                                                        ☀️ {sunTimes.sunrise} → {sunTimes.sunset}
                                                    </div>
                                                </div>
                                                
                                                <button
                                                    onClick={() => {
                                                        setCreateEventDate(date);
                                                        setShowCreateEventModal(true);
                                                    }}
                                                    style={{
                                                        width: '100%',
                                                        padding: window.innerWidth < 768 ? '6px' : '8px',
                                                        marginBottom: window.innerWidth < 768 ? '8px' : '12px',
                                                        backgroundColor: '#ec4899',
                                                        color: 'white',
                                                        borderRadius: '6px',
                                                        border: 'none',
                                                        cursor: 'pointer',
                                                        fontSize: window.innerWidth < 768 ? '10px' : '11px',
                                                        fontWeight: '600',
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        justifyContent: 'center',
                                                        gap: '4px'
                                                    }}
                                                >
                                                    <PlusIcon />
                                                    Ajouter événement
                                                </button>
                                                
                                                {dayActivities.length > 0 && (
                                                    <div 
                                                        className="event-list-scroll"
                                                        style={{ 
                                                            width: '100%', 
                                                            maxHeight: window.innerWidth < 768 ? '250px' : '200px', 
                                                            overflowY: 'auto', 
                                                            paddingRight: '4px',
                                                            WebkitOverflowScrolling: 'touch' // Smooth scroll sur iOS
                                                        }}
                                                    >
                                                        {dayActivities.map(act => (
                                                            <div
                                                                key={act.id}
                                                                onClick={(e) => {
                                                                    // Si c'est une tâche et qu'on clique sur la checkbox, ne pas ouvrir le modal
                                                                    if (act.isTask && e.target.type === 'checkbox') {
                                                                        return;
                                                                    }
                                                                    setEditingEvent(act);
                                                                    setShowEditEventModal(true);
                                                                }}
                                                                style={{
                                                                    padding: '6px 8px',
                                                                    backgroundColor: act.color,
                                                                    color: 'white',
                                                                    borderRadius: '6px',
                                                                    fontSize: window.innerWidth < 768 ? '9px' : '10px',
                                                                    fontWeight: '600',
                                                                    marginBottom: '4px',
                                                                    cursor: 'pointer',
                                                                    display: 'flex',
                                                                    justifyContent: 'space-between',
                                                                    alignItems: 'center',
                                                                    transition: 'opacity 0.2s',
                                                                    textDecoration: act.isTask && act.status === 'completed' ? 'line-through' : 'none',
                                                                    opacity: act.isTask && act.status === 'completed' ? 0.7 : 1
                                                                }}
                                                                onMouseEnter={(e) => e.currentTarget.style.opacity = act.isTask && act.status === 'completed' ? '0.6' : '0.9'}
                                                                onMouseLeave={(e) => e.currentTarget.style.opacity = act.isTask && act.status === 'completed' ? '0.7' : '1'}
                                                            >
                                                                <div style={{ display: 'flex', alignItems: 'center', gap: '6px', flex: 1 }}>
                                                                    {act.isTask && (
                                                                        <input
                                                                            type="checkbox"
                                                                            checked={act.status === 'completed'}
                                                                            onChange={async (e) => {
                                                                                e.stopPropagation();
                                                                                const newStatus = e.target.checked ? 'completed' : 'needsAction';
                                                                                try {
                                                                                    await gapi.client.tasks.tasks.patch({
                                                                                        tasklist: act.taskListId,
                                                                                        task: act.id,
                                                                                        status: newStatus,
                                                                                        completed: e.target.checked ? new Date().toISOString() : null
                                                                                    });
                                                                                    
                                                                                    // Mettre à jour localement
                                                                                    const updatedActivities = { ...activities };
                                                                                    const dateKey = `${act.date.getFullYear()}-${String(act.date.getMonth() + 1).padStart(2, '0')}-${String(act.date.getDate()).padStart(2, '0')}`;
                                                                                    const actIndex = updatedActivities[dateKey].findIndex(a => a.id === act.id);
                                                                                    if (actIndex !== -1) {
                                                                                        updatedActivities[dateKey][actIndex].status = newStatus;
                                                                                        updatedActivities[dateKey][actIndex].completed = e.target.checked ? new Date().toISOString() : null;
                                                                                        setActivities(updatedActivities);
                                                                                    }
                                                                                    showToast(e.target.checked ? 'Tâche complétée ✓' : 'Tâche réactivée', 'success');
                                                                                } catch (err) {
                                                                                    console.error('Error updating task:', err);
                                                                                    showToast('Erreur lors de la mise à jour', 'error');
                                                                                }
                                                                            }}
                                                                            style={{ 
                                                                                cursor: 'pointer',
                                                                                width: '14px',
                                                                                height: '14px',
                                                                                margin: 0
                                                                            }}
                                                                            onClick={(e) => e.stopPropagation()}
                                                                        />
                                                                    )}
                                                                    <span style={{ flex: 1 }}>
                                                                        {act.isTask ? act.title : `${act.startTime} • ${act.title}`}
                                                                        {act.isTask && act.taskListTitle && (
                                                                            <span style={{ opacity: 0.8, fontSize: '8px', marginLeft: '4px' }}>
                                                                                ({act.taskListTitle})
                                                                            </span>
                                                                        )}
                                                                    </span>
                                                                </div>
                                                                <EditIcon />
                                                            </div>
                                                        ))}
                                                    </div>
                                                )}
                                            </>
                                        );
                                    })()}
                                </div>
                            </foreignObject>
                        </svg>
                    </div>
                );
            };

            // ===== TASKS SIDEBAR =====
            const TasksSidebar = ({ activities, onTaskClick, onTaskToggle, isOpen, onClose }) => {
                // Extraire toutes les tâches de activities
                const allTasks = [];
                Object.keys(activities).forEach(dateKey => {
                    activities[dateKey].forEach(activity => {
                        if (activity.isTask) {
                            allTasks.push({
                                ...activity,
                                dateKey
                            });
                        }
                    });
                });

                // Trier les tâches par date d'échéance
                allTasks.sort((a, b) => {
                    // Tâches complétées à la fin
                    if (a.status === 'completed' && b.status !== 'completed') return 1;
                    if (a.status !== 'completed' && b.status === 'completed') return -1;
                    // Sinon par date
                    return a.date - b.date;
                });

                // Grouper par statut
                const activeTasks = allTasks.filter(t => t.status !== 'completed');
                const completedTasks = allTasks.filter(t => t.status === 'completed');

                if (!isOpen) return null;

                return (
                    <div style={{
                        width: window.innerWidth < 768 ? '100%' : '350px',
                        minWidth: window.innerWidth < 768 ? '100%' : '350px',
                        backgroundColor: 'white',
                        borderLeft: window.innerWidth < 768 ? 'none' : '1px solid #e5e7eb',
                        borderTop: window.innerWidth < 768 ? '1px solid #e5e7eb' : 'none',
                        display: 'flex',
                        flexDirection: 'column',
                        maxHeight: window.innerWidth < 768 ? '500px' : 'calc(100vh - 180px)',
                        order: window.innerWidth < 768 ? 3 : 3
                    }}>
                            {/* Header */}
                            <div style={{
                                padding: '20px',
                                borderBottom: '1px solid #e5e7eb',
                                display: 'flex',
                                justifyContent: 'space-between',
                                alignItems: 'center',
                                backgroundColor: '#F59E0B',
                                color: 'white'
                            }}>
                                <h2 style={{ margin: 0, fontSize: '20px', fontWeight: '700' }}>
                                    ✓ Mes Tâches
                                </h2>
                                <button
                                    onClick={onClose}
                                    style={{
                                        border: 'none',
                                        background: 'none',
                                        cursor: 'pointer',
                                        color: 'white',
                                        fontSize: '24px',
                                        padding: '4px'
                                    }}
                                >
                                    ×
                                </button>
                            </div>

                            {/* Contenu */}
                            <div style={{
                                flex: 1,
                                overflowY: 'auto',
                                padding: '16px'
                            }}>
                                {allTasks.length === 0 ? (
                                    <div style={{
                                        textAlign: 'center',
                                        padding: '40px 20px',
                                        color: '#9ca3af'
                                    }}>
                                        <div style={{ fontSize: '48px', marginBottom: '16px' }}>📝</div>
                                        <p style={{ margin: 0, fontSize: '14px' }}>
                                            Aucune tâche avec échéance.<br/>
                                            Synchronisez pour voir vos tâches Google Tasks.
                                        </p>
                                    </div>
                                ) : (
                                    <>
                                        {/* Tâches actives */}
                                        {activeTasks.length > 0 && (
                                            <div style={{ marginBottom: '24px' }}>
                                                <h3 style={{
                                                    margin: '0 0 12px 0',
                                                    fontSize: '14px',
                                                    fontWeight: '600',
                                                    color: '#6b7280',
                                                    textTransform: 'uppercase',
                                                    letterSpacing: '0.05em'
                                                }}>
                                                    À faire ({activeTasks.length})
                                                </h3>
                                                {activeTasks.map(task => (
                                                    <div
                                                        key={task.id}
                                                        onClick={(e) => {
                                                            if (e.target.type !== 'checkbox') {
                                                                onTaskClick(task);
                                                            }
                                                        }}
                                                        style={{
                                                            padding: '12px',
                                                            marginBottom: '8px',
                                                            backgroundColor: '#fef3c7',
                                                            border: '1px solid #fbbf24',
                                                            borderRadius: '8px',
                                                            cursor: 'pointer',
                                                            transition: 'all 0.2s'
                                                        }}
                                                        onMouseEnter={(e) => {
                                                            e.currentTarget.style.backgroundColor = '#fde68a';
                                                            e.currentTarget.style.transform = 'translateX(-2px)';
                                                        }}
                                                        onMouseLeave={(e) => {
                                                            e.currentTarget.style.backgroundColor = '#fef3c7';
                                                            e.currentTarget.style.transform = 'translateX(0)';
                                                        }}
                                                    >
                                                        <div style={{ display: 'flex', alignItems: 'flex-start', gap: '8px' }}>
                                                            <input
                                                                type="checkbox"
                                                                checked={false}
                                                                onChange={(e) => {
                                                                    e.stopPropagation();
                                                                    onTaskToggle(task, true);
                                                                }}
                                                                onClick={(e) => e.stopPropagation()}
                                                                style={{
                                                                    marginTop: '2px',
                                                                    cursor: 'pointer',
                                                                    width: '18px',
                                                                    height: '18px'
                                                                }}
                                                            />
                                                            <div style={{ flex: 1 }}>
                                                                <div style={{
                                                                    fontWeight: '600',
                                                                    fontSize: '14px',
                                                                    color: '#92400e',
                                                                    marginBottom: '4px'
                                                                }}>
                                                                    {task.title}
                                                                </div>
                                                                <div style={{
                                                                    fontSize: '12px',
                                                                    color: '#78350f',
                                                                    display: 'flex',
                                                                    gap: '8px',
                                                                    flexWrap: 'wrap'
                                                                }}>
                                                                    <span>
                                                                        {task.hasNoDueDate ? '📌 Pas d\'échéance' : `📅 ${task.date.toLocaleDateString('fr-FR', { weekday: 'short', day: 'numeric', month: 'short' })}`}
                                                                    </span>
                                                                    {task.taskListTitle && (
                                                                        <span>📋 {task.taskListTitle}</span>
                                                                    )}
                                                                </div>
                                                            </div>
                                                        </div>
                                                    </div>
                                                ))}
                                            </div>
                                        )}

                                        {/* Tâches complétées */}
                                        {completedTasks.length > 0 && (
                                            <div>
                                                <h3 style={{
                                                    margin: '0 0 12px 0',
                                                    fontSize: '14px',
                                                    fontWeight: '600',
                                                    color: '#6b7280',
                                                    textTransform: 'uppercase',
                                                    letterSpacing: '0.05em'
                                                }}>
                                                    Terminées ({completedTasks.length})
                                                </h3>
                                                {completedTasks.map(task => (
                                                    <div
                                                        key={task.id}
                                                        onClick={(e) => {
                                                            if (e.target.type !== 'checkbox') {
                                                                onTaskClick(task);
                                                            }
                                                        }}
                                                        style={{
                                                            padding: '12px',
                                                            marginBottom: '8px',
                                                            backgroundColor: '#f3f4f6',
                                                            border: '1px solid #d1d5db',
                                                            borderRadius: '8px',
                                                            cursor: 'pointer',
                                                            opacity: 0.7,
                                                            transition: 'all 0.2s'
                                                        }}
                                                        onMouseEnter={(e) => {
                                                            e.currentTarget.style.opacity = '0.85';
                                                            e.currentTarget.style.transform = 'translateX(-2px)';
                                                        }}
                                                        onMouseLeave={(e) => {
                                                            e.currentTarget.style.opacity = '0.7';
                                                            e.currentTarget.style.transform = 'translateX(0)';
                                                        }}
                                                    >
                                                        <div style={{ display: 'flex', alignItems: 'flex-start', gap: '8px' }}>
                                                            <input
                                                                type="checkbox"
                                                                checked={true}
                                                                onChange={(e) => {
                                                                    e.stopPropagation();
                                                                    onTaskToggle(task, false);
                                                                }}
                                                                onClick={(e) => e.stopPropagation()}
                                                                style={{
                                                                    marginTop: '2px',
                                                                    cursor: 'pointer',
                                                                    width: '18px',
                                                                    height: '18px'
                                                                }}
                                                            />
                                                            <div style={{ flex: 1 }}>
                                                                <div style={{
                                                                    fontWeight: '600',
                                                                    fontSize: '14px',
                                                                    color: '#6b7280',
                                                                    marginBottom: '4px',
                                                                    textDecoration: 'line-through'
                                                                }}>
                                                                    {task.title}
                                                                </div>
                                                                <div style={{
                                                                    fontSize: '12px',
                                                                    color: '#9ca3af',
                                                                    display: 'flex',
                                                                    gap: '8px',
                                                                    flexWrap: 'wrap'
                                                                }}>
                                                                    <span>
                                                                        {task.hasNoDueDate ? '📌 Pas d\'échéance' : `📅 ${task.date.toLocaleDateString('fr-FR', { weekday: 'short', day: 'numeric', month: 'short' })}`}
                                                                    </span>
                                                                    {task.taskListTitle && (
                                                                        <span>📋 {task.taskListTitle}</span>
                                                                    )}
                                                                </div>
                                                            </div>
                                                        </div>
                                                    </div>
                                                ))}
                                            </div>
                                        )}
                                    </>
                                )}
                            </div>
                    </div>
                );
            };

            const Toast = ({ message, type }) => {
                const colors = {
                    success: '#16a34a',
                    error: '#ef4444',
                    info: '#3b82f6'
                };

                return (
                    <div className="toast" style={{ borderLeft: `4px solid ${colors[type]}` }}>
                        <span style={{ fontSize: '14px', fontWeight: '500' }}>{message}</span>
                    </div>
                );
            };

            return (
                <div style={{ minHeight: '100vh', backgroundColor: '#f9fafb' }}>
                    {/* Header */}
                    <div style={{
                        backgroundColor: 'white',
                        borderBottom: '1px solid #e5e7eb',
                        padding: '16px 24px',
                        display: 'flex',
                        justifyContent: 'space-between',
                        alignItems: 'center'
                    }}>
                        <h1 style={{
                            margin: 0,
                            fontSize: '24px',
                            fontWeight: '700',
                            background: 'linear-gradient(135deg, #ec4899 0%, #8b5cf6 100%)',
                            WebkitBackgroundClip: 'text',
                            WebkitTextFillColor: 'transparent'
                        }}>
                            Lunarium 🌸
                        </h1>

                        <div style={{ display: 'flex', gap: '8px' }}>
                            <button
                                onClick={() => setShowTasksSidebar(true)}
                                style={{
                                    padding: '8px 16px',
                                    backgroundColor: '#F59E0B',
                                    color: 'white',
                                    borderRadius: '8px',
                                    cursor: 'pointer',
                                    border: 'none',
                                    display: 'flex',
                                    alignItems: 'center',
                                    gap: '8px',
                                    fontSize: '14px',
                                    fontWeight: '500',
                                    transition: 'all 0.2s'
                                }}
                                onMouseEnter={(e) => e.currentTarget.style.backgroundColor = '#D97706'}
                                onMouseLeave={(e) => e.currentTarget.style.backgroundColor = '#F59E0B'}
                            >
                                ✓ Tâches
                            </button>
                            <button
                                onClick={() => setShowConfigModal(true)}
                                style={{
                                    padding: '8px 16px',
                                    backgroundColor: 'white',
                                    color: '#6b7280',
                                    borderRadius: '8px',
                                    cursor: 'pointer',
                                    border: '1px solid #e5e7eb',
                                display: 'flex',
                                alignItems: 'center',
                                gap: '8px',
                                fontSize: '14px',
                                fontWeight: '500'
                            }}
                        >
                            <SettingsIcon />
                            Configuration
                        </button>
                        </div>
                    </div>

                    {/* Onglets */}
                    <div style={{
                        backgroundColor: 'white',
                        borderBottom: '1px solid #e5e7eb',
                        padding: '0 24px',
                        display: 'flex',
                        gap: '8px'
                    }}>
                        <button
                            onClick={() => setCurrentView('cycle')}
                            style={{
                                padding: '12px 24px',
                                backgroundColor: 'transparent',
                                border: 'none',
                                borderBottom: currentView === 'cycle' ? '3px solid #ec4899' : '3px solid transparent',
                                cursor: 'pointer',
                                fontSize: '14px',
                                fontWeight: '600',
                                color: currentView === 'cycle' ? '#ec4899' : '#6b7280',
                                transition: 'all 0.2s'
                            }}
                        >
                            Vue Cyclique
                        </button>
                        <button
                            onClick={() => setCurrentView('month')}
                            style={{
                                padding: '12px 24px',
                                backgroundColor: 'transparent',
                                border: 'none',
                                borderBottom: currentView === 'month' ? '3px solid #ec4899' : '3px solid transparent',
                                cursor: 'pointer',
                                fontSize: '14px',
                                fontWeight: '600',
                                color: currentView === 'month' ? '#ec4899' : '#6b7280',
                                transition: 'all 0.2s'
                            }}
                        >
                            Vue Mensuelle
                        </button>
                    </div>

                    {/* Layout principal avec sidebar */}
                    <div style={{ display: 'flex', minHeight: 'calc(100vh - 180px)', flexDirection: window.innerWidth < 768 ? 'column' : 'row', gap: window.innerWidth < 768 ? '0' : '0' }}>
                        {/* Sidebar calendriers à gauche */}
                        <div style={{
                            width: window.innerWidth < 768 ? '100%' : '280px',
                            minWidth: window.innerWidth < 768 ? '100%' : '280px',
                            backgroundColor: '#f9fafb',
                            borderRight: window.innerWidth < 768 ? 'none' : '1px solid #e5e7eb',
                            borderBottom: window.innerWidth < 768 ? '1px solid #e5e7eb' : 'none',
                            overflowY: 'auto',
                            padding: '16px',
                            maxHeight: window.innerWidth < 768 ? '500px' : 'calc(100vh - 180px)',
                            order: window.innerWidth < 768 ? 2 : 1
                        }}>
                            {/* Pas de widget Tasks séparé - tout est synchronisé avec Google Calendar */}
                            <GoogleCalendarSync
                                onSync={(events, calendarMap) => {
                                    console.log('=== SYNC START ===');
                                    console.log('Total events received:', events.length);
                                    
                                    const newActivities = {};
                                    
                                    events.forEach(event => {
                                        // Gérer à la fois les événements (dateTime) et les tâches (date)
                                        let startDate, endDate, dateKey;
                                        
                                        if (event.isTask && event.start && event.start.date) {
                                            // Tâche avec date d'échéance
                                            startDate = new Date(event.start.date + 'T00:00:00');
                                            endDate = startDate;
                                        } else if (event.start && event.start.dateTime) {
                                            // Événement avec heure
                                            startDate = new Date(event.start.dateTime);
                                            endDate = new Date(event.end.dateTime);
                                        } else if (event.start && event.start.date) {
                                            // Événement all-day
                                            startDate = new Date(event.start.date + 'T00:00:00');
                                            endDate = new Date(event.end.date + 'T23:59:59');
                                        } else {
                                            // Pas de date valide, ignorer
                                            return;
                                        }
                                        
                                        const year = startDate.getFullYear();
                                        const month = String(startDate.getMonth() + 1).padStart(2, '0');
                                        const day = String(startDate.getDate()).padStart(2, '0');
                                        dateKey = `${year}-${month}-${day}`;
                                        
                                        if (!newActivities[dateKey]) {
                                            newActivities[dateKey] = [];
                                        }
                                        
                                        // Déterminer la couleur: backgroundColor > colorId > calendar color
                                        let eventColor = '#3b82f6'; // Couleur par défaut
                                        if (event.backgroundColor) {
                                            eventColor = event.backgroundColor;
                                        } else if (event.colorId) {
                                            eventColor = getGoogleColor(event.colorId);
                                        } else if (calendarMap && calendarMap[event.calendarId]) {
                                            eventColor = calendarMap[event.calendarId];
                                        }
                                        
                                        // Créer l'activité de base
                                        const activity = {
                                            id: event.id,
                                            title: event.summary || (event.isTask ? 'Tâche sans titre' : 'Sans titre'),
                                            color: eventColor,
                                            description: event.description || '',
                                            calendarId: event.calendarId,
                                            date: startDate,
                                            isTask: event.isTask || false
                                        };
                                        
                                        // Ajouter les propriétés spécifiques selon le type
                                        if (event.isTask) {
                                            activity.taskListId = event.taskListId;
                                            activity.taskListTitle = event.taskListTitle;
                                            activity.status = event.status;
                                            activity.completed = event.completed;
                                            activity.hasNoDueDate = event.hasNoDueDate || false;
                                            activity.startTime = '';
                                            activity.duration = 0;
                                        } else {
                                            activity.startTime = event.start.dateTime ? startDate.toTimeString().slice(0, 5) : '';
                                            activity.duration = Math.round((endDate - startDate) / (1000 * 60));
                                        }
                                        
                                        newActivities[dateKey].push(activity);
                                    });
                                    
                                    console.log('=== SYNC END ===');
                                    
                                    // Trier tous les événements de chaque jour
                                    Object.keys(newActivities).forEach(dateKey => {
                                        newActivities[dateKey].sort((a, b) => {
                                            // Tâches complétées à la fin
                                            if (a.isTask && b.isTask) {
                                                const aCompleted = a.status === 'completed';
                                                const bCompleted = b.status === 'completed';
                                                if (aCompleted !== bCompleted) {
                                                    return aCompleted ? 1 : -1;
                                                }
                                            }
                                            // Tâches après les événements
                                            if (a.isTask !== b.isTask) {
                                                return a.isTask ? 1 : -1;
                                            }
                                            // Sinon tri par heure
                                            if (!a.isTask && !b.isTask && a.startTime && b.startTime) {
                                                const timeA = a.startTime.split(':').map(Number);
                                                const timeB = b.startTime.split(':').map(Number);
                                                return (timeA[0] * 60 + timeA[1]) - (timeB[0] * 60 + timeB[1]);
                                            }
                                            return 0;
                                        });
                                    });
                                    
                                    setActivities(newActivities);
                                    showToast('Synchronisation réussie ✓', 'success');
                                }}
                                onError={(msg) => showToast(msg, 'error')}
                                onCalendarsLoaded={(cals) => setGoogleCalendars(cals)}
                                onSyncRequest={(syncFn) => setSyncFunction(() => syncFn)}
                            />
                        </div>

                        {/* Contenu principal */}
                        <div style={{ 
                            flex: 1, 
                            padding: '24px', 
                            overflowY: 'auto',
                            order: window.innerWidth < 768 ? 1 : 2
                        }}>
                            <div style={{
                                background: 'white',
                                borderRadius: '12px',
                                padding: '24px',
                                boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
                            }}>
                                {currentView === 'cycle' ? (
                                    renderCircleView()
                                ) : (
                                    <MonthView
                                        currentMonth={currentMonth}
                                        onMonthChange={setCurrentMonth}
                                        activities={activities}
                                        getPhaseForDate={getPhaseForDate}
                                        onDayClick={(date) => {
                                            setCreateEventDate(date);
                                            setShowCreateEventModal(true);
                                        }}
                                        googleCalendars={googleCalendars}
                                    />
                                )}
                            </div>
                        </div>

                        {/* Tasks Sidebar */}
                        <TasksSidebar
                            activities={activities}
                            isOpen={showTasksSidebar}
                            onClose={() => setShowTasksSidebar(false)}
                            onTaskClick={(task) => {
                                setEditingEvent(task);
                                setShowEditEventModal(true);
                            }}
                            onTaskToggle={async (task, completed) => {
                                const newStatus = completed ? 'completed' : 'needsAction';
                                try {
                                    await gapi.client.tasks.tasks.patch({
                                        tasklist: task.taskListId,
                                        task: task.id,
                                        status: newStatus,
                                        completed: completed ? new Date().toISOString() : null
                                    });

                                    // Mettre à jour localement
                                    const updatedActivities = { ...activities };
                                    const dateKey = `${task.date.getFullYear()}-${String(task.date.getMonth() + 1).padStart(2, '0')}-${String(task.date.getDate()).padStart(2, '0')}`;
                                    const actIndex = updatedActivities[dateKey].findIndex(a => a.id === task.id);
                                    if (actIndex !== -1) {
                                        updatedActivities[dateKey][actIndex].status = newStatus;
                                        updatedActivities[dateKey][actIndex].completed = completed ? new Date().toISOString() : null;
                                        setActivities(updatedActivities);
                                    }
                                    showToast(completed ? 'Tâche complétée ✓' : 'Tâche réactivée', 'success');
                                } catch (err) {
                                    console.error('Error updating task:', err);
                                    showToast('Erreur lors de la mise à jour', 'error');
                                }
                            }}
                        />
                    </div>

                    {/* Modals */}
                    {showConfigModal && (
                        <ConfigModal
                            config={cycleConfig}
                            cycleHistory={cycleHistory}
                            onSave={(newConfig) => {
                                setCycleConfig({
                                    cycleStartDate: newConfig.cycleStartDate,
                                    cycleLength: newConfig.cycleLength
                                });
                                if (newConfig.cycleHistory) {
                                    setCycleHistory(newConfig.cycleHistory);
                                }
                                setShowConfigModal(false);
                                showToast('Configuration enregistrée ✓', 'success');
                            }}
                            onClose={() => setShowConfigModal(false)}
                        />
                    )}

                    {showCreateEventModal && googleCalendars.length > 0 && (
                        <CreateEventModal
                            date={createEventDate}
                            calendars={googleCalendars}
                            onCreate={createEvent}
                            onClose={() => {
                                setShowCreateEventModal(false);
                                setCreateEventDate(null);
                            }}
                        />
                    )}

                    {showEditEventModal && editingEvent && (
                        editingEvent.isTask ? (
                            <EditTaskModal
                                task={editingEvent}
                                onSync={syncFunction}
                                onClose={() => {
                                    setShowEditEventModal(false);
                                    setEditingEvent(null);
                                }}
                            />
                        ) : googleCalendars.length > 0 ? (
                            <EditEventModal
                                event={editingEvent}
                                calendars={googleCalendars}
                                onUpdate={updateEvent}
                                onDelete={deleteEvent}
                                onClose={() => {
                                    setShowEditEventModal(false);
                                    setEditingEvent(null);
                                }}
                            />
                        ) : null
                    )}

                    {/* Toast */}
                    {toast && <Toast message={toast.message} type={toast.type} />}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<LunariumPlanner />);
    </script>
</body>
</html>
