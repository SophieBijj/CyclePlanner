<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#ec4899">
    <title>Lunarium 🌸</title>
    
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            background-color: #f9fafb;
        }
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 16px 24px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 10000;
            animation: slideIn 0.3s ease-out;
        }
        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        .cycle-segment {
            cursor: pointer;
            transition: opacity 0.2s;
        }
        .cycle-segment:hover {
            opacity: 0.85;
        }
        .sync-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid #e5e7eb;
            border-top-color: #3b82f6;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // CONFIGURATION GOOGLE CALENDAR API
        const GOOGLE_CLIENT_ID = '711219272291-i1je9vqn1b4p0asn4fov7bdohoa08q38.apps.googleusercontent.com';
        const GOOGLE_API_KEY = 'AIzaSyA81G3xJq6iTJitDv6GO_rvjaOucTpeDNA';
        const DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest';
        const SCOPES = 'https://www.googleapis.com/auth/calendar';

        // ===== ICÔNES =====
        const GoogleIcon = () => (
            <svg width="18" height="18" viewBox="0 0 24 24">
                <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
            </svg>
        );

        const SyncIcon = () => (
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polyline points="23 4 23 10 17 10"></polyline>
                <polyline points="1 20 1 14 7 14"></polyline>
                <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
            </svg>
        );

        const SettingsIcon = () => (
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <circle cx="12" cy="12" r="3"></circle>
                <path d="M12 1v6m0 6v6m5.66-17a10 10 0 0 1 0 16M6.34 4a10 10 0 0 0 0 16"></path>
            </svg>
        );

        const XIcon = () => (
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
        );

        // ===== FONCTIONS UTILITAIRES =====
        function getSunTimes(date) {
            const lat = 45.5017; // Montréal
            const lng = -73.5673;
            
            const year = date.getFullYear();
            const month = date.getMonth() + 1;
            const day = date.getDate();
            
            const a = Math.floor((14 - month) / 12);
            const y = year + 4800 - a;
            const m = month + 12 * a - 3;
            const jd = day + Math.floor((153 * m + 2) / 5) + 365 * y + 
                       Math.floor(y / 4) - Math.floor(y / 100) + Math.floor(y / 400) - 32045;
            const n = jd - 2451545.0;
            
            const L = (280.460 + 0.9856474 * n) % 360;
            const g = (357.528 + 0.9856003 * n) % 360;
            const gRad = g * Math.PI / 180;
            const lambda = (L + 1.915 * Math.sin(gRad) + 0.020 * Math.sin(2 * gRad)) % 360;
            const lambdaRad = lambda * Math.PI / 180;
            const epsilon = 23.439 - 0.0000004 * n;
            const epsilonRad = epsilon * Math.PI / 180;
            const dec = Math.asin(Math.sin(epsilonRad) * Math.sin(lambdaRad)) * 180 / Math.PI;
            
            const latRad = lat * Math.PI / 180;
            const decRad = dec * Math.PI / 180;
            const cosH = -Math.tan(latRad) * Math.tan(decRad);
            
            if (cosH > 1 || cosH < -1) {
                return { sunrise: '07:30', sunset: '17:00', sunriseDecimal: 7.5, sunsetDecimal: 17 };
            }
            
            const H = Math.acos(cosH) * 180 / Math.PI;
            const eqTime = 4 * (L - lambda);
            const sunriseUTC = 12 - H / 15 - eqTime / 60 - lng / 15;
            const sunsetUTC = 12 + H / 15 - eqTime / 60 - lng / 15;
            
            const tzOffset = -date.getTimezoneOffset() / 60;
            const sunriseLocal = (sunriseUTC + tzOffset + 24) % 24;
            const sunsetLocal = (sunsetUTC + tzOffset + 24) % 24;
            
            const formatTime = (hours) => {
                const h = Math.floor(hours);
                const m = Math.floor((hours - h) * 60);
                return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
            };
            
            return {
                sunrise: formatTime(sunriseLocal),
                sunset: formatTime(sunsetLocal),
                sunriseDecimal: sunriseLocal,
                sunsetDecimal: sunsetLocal
            };
        }

        function getPhaseInfo(cycleDay, cycleLength) {
            const ovulationDay = cycleLength - 14;
            
            if (cycleDay >= 1 && cycleDay <= 5) {
                return { 
                    name: 'Menstruation',
                    shortName: 'Lune rouge',
                    color: '#fca5a5', 
                    border: '#f87171', 
                    text: '#7f1d1d',
                    description: 'Repos, introspection, détoxification'
                };
            } else if (cycleDay >= 6 && cycleDay < ovulationDay - 1) {
                return { 
                    name: 'Folliculaire',
                    shortName: 'Jeune Fille',
                    color: '#67e8f9', 
                    border: '#06b6d4', 
                    text: '#164e63',
                    description: 'Créativité, nouveaux projets, brainstorming'
                };
            } else if (cycleDay >= ovulationDay - 1 && cycleDay <= ovulationDay + 1) {
                return { 
                    name: 'Ovulation',
                    shortName: 'Mère',
                    color: '#fcd34d', 
                    border: '#f59e0b', 
                    text: '#78350f',
                    description: 'Communication, collaboration, être présente'
                };
            } else if (cycleDay >= cycleLength - 1 && cycleDay <= cycleLength) {
                return { 
                    name: 'SPM',
                    shortName: 'SPM',
                    color: '#f0abfc', 
                    border: '#c026d3', 
                    text: '#701a75',
                    description: 'Détails, finition, laisser passer la vague'
                };
            } else {
                return { 
                    name: 'Lutéale',
                    shortName: 'Enchanteresse',
                    color: '#f0abfc', 
                    border: '#d946ef', 
                    text: '#701a75',
                    description: 'Intuition, focus, nettoyage'
                };
            }
        }

        function getMoonInfo(date) {
            const knownNewMoon = new Date(2000, 0, 6, 18, 14);
            const lunarCycle = 29.53058867;
            
            const diff = date - knownNewMoon;
            const daysSinceKnownNewMoon = diff / (1000 * 60 * 60 * 24);
            const lunarAge = daysSinceKnownNewMoon % lunarCycle;
            
            const phase = Math.floor((lunarAge / lunarCycle) * 8);
            
            const moonEmojis = ['🌑', '🌒', '🌓', '🌔', '🌕', '🌖', '🌗', '🌘'];
            const moonNames = ['Nouvelle lune', 'Premier croissant', 'Premier quartier', 'Gibbeuse croissante', 
                              'Pleine lune', 'Gibbeuse décroissante', 'Dernier quartier', 'Dernier croissant'];
            
            return { 
                emoji: moonEmojis[phase], 
                name: moonNames[phase],
                age: Math.round(lunarAge * 10) / 10
            };
        }

        // ===== GOOGLE CALENDAR SYNC =====
        const GoogleCalendarSync = ({ onSync, onError }) => {
            const [isSignedIn, setIsSignedIn] = useState(false);
            const [isSyncing, setIsSyncing] = useState(false);
            const [calendars, setCalendars] = useState([]);
            const [selectedCalendars, setSelectedCalendars] = useState([]);
            const [isLoading, setIsLoading] = useState(true);
            const gapiInited = useRef(false);
            const gisInited = useRef(false);
            const tokenClient = useRef(null);

            useEffect(() => {
                let gapiTimeout, gisTimeout;
                
                const checkAndLoad = () => {
                    if (typeof gapi !== 'undefined') {
                        gapiLoaded();
                        clearTimeout(gapiTimeout);
                    } else {
                        gapiTimeout = setTimeout(checkAndLoad, 200);
                    }
                };
                
                const checkAndLoadGis = () => {
                    if (typeof google !== 'undefined' && google.accounts) {
                        gisLoaded();
                        clearTimeout(gisTimeout);
                    } else {
                        gisTimeout = setTimeout(checkAndLoadGis, 200);
                    }
                };
                
                setTimeout(() => {
                    checkAndLoad();
                    checkAndLoadGis();
                }, 500);
                
                setTimeout(() => {
                    if (!gapiInited.current || !gisInited.current) {
                        setIsLoading(false);
                        onError?.('Impossible de charger Google Calendar. Veuillez recharger la page.');
                    }
                }, 10000);
                
                return () => {
                    clearTimeout(gapiTimeout);
                    clearTimeout(gisTimeout);
                };
            }, []);

            const gapiLoaded = () => {
                if (typeof gapi !== 'undefined') {
                    gapi.load('client', initializeGapiClient);
                }
            };

            const initializeGapiClient = async () => {
                try {
                    await gapi.client.init({
                        apiKey: GOOGLE_API_KEY,
                        discoveryDocs: [DISCOVERY_DOC],
                    });
                    gapiInited.current = true;
                    maybeEnableButtons();
                } catch (err) {
                    console.error('Error initializing GAPI:', err);
                    onError?.('Erreur d\'initialisation Google API');
                }
            };

            const gisLoaded = () => {
                if (typeof google !== 'undefined') {
                    tokenClient.current = google.accounts.oauth2.initTokenClient({
                        client_id: GOOGLE_CLIENT_ID,
                        scope: SCOPES,
                        callback: async (response) => {
                            if (response.error) {
                                console.error('Auth error:', response.error);
                                onError?.('Erreur d\'authentification Google');
                                return;
                            }
                            
                            // Sauvegarder le token pour persistance
                            if (response.access_token) {
                                const expiresAt = Date.now() + (response.expires_in * 1000);
                                localStorage.setItem('googleAccessToken', JSON.stringify({
                                    access_token: response.access_token,
                                    expires_at: expiresAt
                                }));
                                
                                // Définir le token dans gapi
                                gapi.client.setToken({
                                    access_token: response.access_token
                                });
                            }
                            
                            setIsSignedIn(true);
                            await loadCalendars(); // loadCalendars s'occupe de l'auto-sync
                        },
                    });
                    gisInited.current = true;
                    maybeEnableButtons();
                }
            };

            const maybeEnableButtons = () => {
                if (gapiInited.current && gisInited.current) {
                    setIsLoading(false);
                    
                    // Essayer de restaurer le token depuis localStorage
                    const savedToken = localStorage.getItem('googleAccessToken');
                    if (savedToken) {
                        try {
                            const tokenData = JSON.parse(savedToken);
                            
                            // Vérifier si le token n'est pas expiré
                            if (tokenData.expires_at && Date.now() < tokenData.expires_at) {
                                console.log('Restoring saved token...');
                                gapi.client.setToken({
                                    access_token: tokenData.access_token
                                });
                            } else {
                                console.log('Saved token expired, clearing...');
                                localStorage.removeItem('googleAccessToken');
                            }
                        } catch (e) {
                            console.error('Error restoring token:', e);
                            localStorage.removeItem('googleAccessToken');
                        }
                    }
                    
                    // Vérifier si on a un token valide
                    const token = gapi.client.getToken();
                    if (token !== null) {
                        console.log('Already signed in, loading calendars...');
                        setIsSignedIn(true);
                        loadCalendars(); // loadCalendars s'occupe maintenant de l'auto-sync
                    }
                }
            };

            const handleAuthClick = () => {
                if (!tokenClient.current) {
                    onError?.('Initialisation en cours, veuillez réessayer dans quelques secondes');
                    return;
                }
                
                if (typeof gapi === 'undefined' || !gapi.client) {
                    onError?.('Google API en cours de chargement, veuillez réessayer');
                    return;
                }
                
                if (gapi.client.getToken() === null) {
                    tokenClient.current.requestAccessToken({ prompt: 'consent' });
                } else {
                    tokenClient.current.requestAccessToken({ prompt: '' });
                }
            };

            const handleSignoutClick = () => {
                if (typeof gapi === 'undefined' || !gapi.client) return;
                
                const token = gapi.client.getToken();
                if (token !== null) {
                    google.accounts.oauth2.revoke(token.access_token);
                    gapi.client.setToken('');
                    
                    // Supprimer le token sauvegardé
                    localStorage.removeItem('googleAccessToken');
                    
                    setIsSignedIn(false);
                    setCalendars([]);
                    setSelectedCalendars([]);
                }
            };

            const loadCalendars = async () => {
                if (typeof gapi === 'undefined' || !gapi.client) return;
                
                try {
                    const response = await gapi.client.calendar.calendarList.list();
                    const cals = response.result.items || [];
                    setCalendars(cals);
                    
                    // Restaurer les calendriers sélectionnés depuis localStorage
                    const savedCalendars = localStorage.getItem('selectedCalendars');
                    if (savedCalendars) {
                        try {
                            const saved = JSON.parse(savedCalendars);
                            // Vérifier que les calendriers sauvegardés existent toujours
                            const validSaved = saved.filter(id => cals.some(cal => cal.id === id));
                            if (validSaved.length > 0) {
                                console.log('Restoring selected calendars:', validSaved);
                                setSelectedCalendars(validSaved);
                                
                                // Auto-sync en passant directement les calendriers pour éviter problème de timing React
                                setTimeout(() => {
                                    console.log('Auto-syncing with restored calendars...');
                                    handleSync(validSaved); // Passer les calendriers directement
                                }, 1000);
                                
                                return; // Ne pas sélectionner le principal par défaut
                            }
                        } catch (e) {
                            console.error('Error parsing saved calendars:', e);
                        }
                    }
                    
                    // Si pas de calendriers sauvegardés, sélectionner le principal
                    const primary = cals.find(cal => cal.primary);
                    if (primary) {
                        setSelectedCalendars([primary.id]);
                        localStorage.setItem('selectedCalendars', JSON.stringify([primary.id]));
                    }
                } catch (err) {
                    console.error('Error loading calendars:', err);
                    onError?.('Erreur de chargement des calendriers');
                }
            };

            const handleSync = async (calendarsToSync = null) => {
                const calendars = calendarsToSync || selectedCalendars;
                
                if (calendars.length === 0) {
                    console.log('Cannot sync: no calendars selected');
                    return;
                }
                if (typeof gapi === 'undefined' || !gapi.client) {
                    onError?.('Google API non disponible');
                    return;
                }
                
                // Vérifier qu'on a un token valide
                const token = gapi.client.getToken();
                if (!token) {
                    console.log('Cannot sync: no valid token');
                    return;
                }
                
                setIsSyncing(true);
                try {
                    const now = new Date();
                    const sixMonthsAgo = new Date(now.getFullYear(), now.getMonth() - 6, 1);
                    const sixMonthsAhead = new Date(now.getFullYear(), now.getMonth() + 6, 31);
                    
                    const allEvents = [];
                    for (const calendarId of calendars) {
                        console.log('Fetching events from calendar:', calendarId);
                        const response = await gapi.client.calendar.events.list({
                            calendarId: calendarId,
                            timeMin: sixMonthsAgo.toISOString(),
                            timeMax: sixMonthsAhead.toISOString(),
                            singleEvents: true,
                            orderBy: 'startTime',
                        });
                        
                        const events = response.result.items || [];
                        console.log(`Found ${events.length} events in calendar ${calendarId}`);
                        allEvents.push(...events.map(e => ({ ...e, calendarId })));
                    }
                    
                    console.log(`Total events found: ${allEvents.length}`);
                    onSync?.(allEvents, calendars[0]);
                } catch (err) {
                    console.error('Error syncing:', err);
                    onError?.('Erreur de synchronisation');
                } finally {
                    setIsSyncing(false);
                }
            };

            const toggleCalendar = (calendarId) => {
                const newSelected = selectedCalendars.includes(calendarId)
                    ? selectedCalendars.filter(id => id !== calendarId)
                    : [...selectedCalendars, calendarId];
                
                setSelectedCalendars(newSelected);
                localStorage.setItem('selectedCalendars', JSON.stringify(newSelected));
            };

            return (
                <div style={{ padding: '20px', background: 'white', borderRadius: '12px', marginBottom: '20px', boxShadow: '0 1px 3px rgba(0,0,0,0.1)' }}>
                    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '16px' }}>
                        <h3 style={{ margin: 0, fontSize: '16px', fontWeight: '600', display: 'flex', alignItems: 'center', gap: '8px' }}>
                            <GoogleIcon />
                            Google Calendar
                        </h3>
                        {!isSignedIn ? (
                            <button
                                onClick={handleAuthClick}
                                disabled={isLoading}
                                style={{
                                    padding: '8px 16px',
                                    backgroundColor: isLoading ? '#9ca3af' : '#4285F4',
                                    color: 'white',
                                    borderRadius: '8px',
                                    fontWeight: '500',
                                    cursor: isLoading ? 'not-allowed' : 'pointer',
                                    border: 'none',
                                    display: 'flex',
                                    alignItems: 'center',
                                    gap: '8px',
                                    fontSize: '14px'
                                }}
                            >
                                <GoogleIcon />
                                {isLoading ? 'Chargement...' : 'Se connecter'}
                            </button>
                        ) : (
                            <div style={{ display: 'flex', gap: '8px' }}>
                                <button
                                    onClick={handleSync}
                                    disabled={isSyncing || selectedCalendars.length === 0}
                                    style={{
                                        padding: '8px 16px',
                                        backgroundColor: isSyncing ? '#9ca3af' : '#16a34a',
                                        color: 'white',
                                        borderRadius: '8px',
                                        fontWeight: '500',
                                        cursor: isSyncing ? 'not-allowed' : 'pointer',
                                        border: 'none',
                                        display: 'flex',
                                        alignItems: 'center',
                                        gap: '8px',
                                        fontSize: '14px'
                                    }}
                                >
                                    <SyncIcon />
                                    {isSyncing ? 'Synchronisation...' : 'Synchroniser'}
                                </button>
                                <button
                                    onClick={handleSignoutClick}
                                    style={{
                                        padding: '8px 16px',
                                        backgroundColor: '#ef4444',
                                        color: 'white',
                                        borderRadius: '8px',
                                        fontWeight: '500',
                                        cursor: 'pointer',
                                        border: 'none',
                                        fontSize: '14px'
                                    }}
                                >
                                    Déconnecter
                                </button>
                            </div>
                        )}
                    </div>

                    {isSignedIn && calendars.length > 0 && (
                        <div>
                            <p style={{ fontSize: '13px', color: '#6b7280', marginBottom: '12px' }}>
                                Calendriers synchronisés :
                            </p>
                            <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                                {calendars.map(cal => (
                                    <label
                                        key={cal.id}
                                        style={{
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: '8px',
                                            padding: '8px',
                                            borderRadius: '6px',
                                            cursor: 'pointer',
                                            background: selectedCalendars.includes(cal.id) ? '#f0fdf4' : 'transparent'
                                        }}
                                    >
                                        <input
                                            type="checkbox"
                                            checked={selectedCalendars.includes(cal.id)}
                                            onChange={() => toggleCalendar(cal.id)}
                                            style={{ cursor: 'pointer' }}
                                        />
                                        <div
                                            style={{
                                                width: '12px',
                                                height: '12px',
                                                borderRadius: '50%',
                                                backgroundColor: cal.backgroundColor || '#3b82f6'
                                            }}
                                        />
                                        <span style={{ fontSize: '14px' }}>
                                            {cal.summary} {cal.primary && '(Principal)'}
                                        </span>
                                    </label>
                                ))}
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // ===== CONFIG MODAL =====
        const ConfigModal = ({ config, onSave, onClose }) => {
            const [startDate, setStartDate] = useState(config.cycleStartDate.toISOString().split('T')[0]);
            const [cycleLength, setCycleLength] = useState(config.cycleLength);

            return (
                <div style={{
                    position: 'fixed',
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0,
                    backgroundColor: 'rgba(0,0,0,0.5)',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    zIndex: 1000
                }}>
                    <div style={{
                        backgroundColor: 'white',
                        borderRadius: '12px',
                        padding: '24px',
                        maxWidth: '500px',
                        width: '90%',
                        boxShadow: '0 20px 25px -5px rgba(0,0,0,0.1)'
                    }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '24px' }}>
                            <h2 style={{ margin: 0, fontSize: '20px', fontWeight: '600' }}>Configuration du cycle</h2>
                            <button onClick={onClose} style={{ cursor: 'pointer', border: 'none', background: 'none' }}>
                                <XIcon />
                            </button>
                        </div>

                        <div style={{ marginBottom: '20px' }}>
                            <label style={{ display: 'block', marginBottom: '8px', fontSize: '14px', fontWeight: '500' }}>
                                Premier jour des dernières règles
                            </label>
                            <input
                                type="date"
                                value={startDate}
                                onChange={(e) => setStartDate(e.target.value)}
                                style={{
                                    width: '100%',
                                    padding: '10px',
                                    borderRadius: '8px',
                                    border: '1px solid #e5e7eb',
                                    fontSize: '14px'
                                }}
                            />
                        </div>

                        <div style={{ marginBottom: '24px' }}>
                            <label style={{ display: 'block', marginBottom: '8px', fontSize: '14px', fontWeight: '500' }}>
                                Durée du cycle (jours)
                            </label>
                            <input
                                type="number"
                                min="21"
                                max="35"
                                value={cycleLength}
                                onChange={(e) => setCycleLength(parseInt(e.target.value))}
                                style={{
                                    width: '100%',
                                    padding: '10px',
                                    borderRadius: '8px',
                                    border: '1px solid #e5e7eb',
                                    fontSize: '14px'
                                }}
                            />
                        </div>

                        <div style={{ display: 'flex', gap: '12px', justifyContent: 'flex-end' }}>
                            <button
                                onClick={onClose}
                                style={{
                                    padding: '10px 20px',
                                    borderRadius: '8px',
                                    border: '1px solid #e5e7eb',
                                    background: 'white',
                                    cursor: 'pointer',
                                    fontSize: '14px',
                                    fontWeight: '500'
                                }}
                            >
                                Annuler
                            </button>
                            <button
                                onClick={() => onSave({ cycleStartDate: new Date(startDate), cycleLength })}
                                style={{
                                    padding: '10px 20px',
                                    borderRadius: '8px',
                                    border: 'none',
                                    background: '#ec4899',
                                    color: 'white',
                                    cursor: 'pointer',
                                    fontSize: '14px',
                                    fontWeight: '500'
                                }}
                            >
                                Enregistrer
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // ===== COMPOSANT PRINCIPAL =====
        function LunariumPlanner() {
            const [activities, setActivities] = useState({});
            const [toast, setToast] = useState(null);
            const [showConfigModal, setShowConfigModal] = useState(false);
            const [selectedCircleDay, setSelectedCircleDay] = useState(null);
            const [selectedDate, setSelectedDate] = useState(null);

            const [cycleConfig, setCycleConfig] = useState(() => {
                const saved = localStorage.getItem('cycleConfig');
                if (saved) {
                    try {
                        const parsed = JSON.parse(saved);
                        
                        // Parser la date en temps local (pas UTC)
                        let startDate;
                        if (typeof parsed.cycleStartDate === 'string') {
                            // Si c'est au format YYYY-MM-DD, créer une date locale
                            const parts = parsed.cycleStartDate.split('T')[0].split('-');
                            if (parts.length === 3) {
                                startDate = new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
                            } else {
                                startDate = new Date(parsed.cycleStartDate);
                            }
                        } else {
                            startDate = new Date(parsed.cycleStartDate);
                        }
                        
                        // Vérifier que la date est valide
                        if (isNaN(startDate.getTime())) {
                            console.error('Invalid date in localStorage, using today');
                            return {
                                cycleLength: 28,
                                cycleStartDate: new Date()
                            };
                        }
                        return {
                            cycleLength: parsed.cycleLength || 28,
                            cycleStartDate: startDate
                        };
                    } catch (e) {
                        console.error('Error parsing cycleConfig:', e);
                        return {
                            cycleLength: 28,
                            cycleStartDate: new Date()
                        };
                    }
                }
                return {
                    cycleLength: 28,
                    cycleStartDate: new Date()
                };
            });

            useEffect(() => {
                if (cycleConfig.cycleStartDate && !isNaN(cycleConfig.cycleStartDate.getTime())) {
                    // Sauvegarder en format local YYYY-MM-DD pour éviter les problèmes de fuseau horaire
                    const year = cycleConfig.cycleStartDate.getFullYear();
                    const month = String(cycleConfig.cycleStartDate.getMonth() + 1).padStart(2, '0');
                    const day = String(cycleConfig.cycleStartDate.getDate()).padStart(2, '0');
                    const dateString = `${year}-${month}-${day}`;
                    
                    localStorage.setItem('cycleConfig', JSON.stringify({
                        cycleLength: cycleConfig.cycleLength,
                        cycleStartDate: dateString
                    }));
                }
            }, [cycleConfig]);

            const getCycleDay = (date) => {
                if (!cycleConfig.cycleStartDate || isNaN(cycleConfig.cycleStartDate.getTime())) {
                    return 1; // Retourner jour 1 par défaut si date invalide
                }
                const diffTime = date - cycleConfig.cycleStartDate;
                const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
                const cycleDay = ((diffDays % cycleConfig.cycleLength) + cycleConfig.cycleLength) % cycleConfig.cycleLength;
                return cycleDay === 0 ? cycleConfig.cycleLength : cycleDay;
            };

            const getDateForCycleDay = (cycleDay) => {
                try {
                    const currentCycleDay = getCycleDay(new Date());
                    const daysToAdd = cycleDay - currentCycleDay;
                    const date = new Date();
                    date.setDate(date.getDate() + daysToAdd);
                    
                    // Vérifier que la date calculée est valide
                    if (isNaN(date.getTime())) {
                        console.error('Invalid date calculated for cycle day:', cycleDay);
                        return new Date(); // Retourner aujourd'hui par défaut
                    }
                    
                    return date;
                } catch (e) {
                    console.error('Error in getDateForCycleDay:', e);
                    return new Date();
                }
            };

            const formatDate = (date) => {
                if (!date || isNaN(date.getTime())) {
                    const today = new Date();
                    const year = today.getFullYear();
                    const month = String(today.getMonth() + 1).padStart(2, '0');
                    const day = String(today.getDate()).padStart(2, '0');
                    return `${year}-${month}-${day}`;
                }
                // Utiliser la date locale au lieu d'UTC
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            };

            const syncFromGoogleCalendar = (googleEvents) => {
                const newActivities = {};
                
                googleEvents.forEach(event => {
                    if (!event.start || !event.start.dateTime) return;
                    
                    const startDate = new Date(event.start.dateTime);
                    const endDate = new Date(event.end.dateTime);
                    
                    // Utiliser la date locale au lieu de UTC pour éviter les décalages
                    const year = startDate.getFullYear();
                    const month = String(startDate.getMonth() + 1).padStart(2, '0');
                    const day = String(startDate.getDate()).padStart(2, '0');
                    const dateKey = `${year}-${month}-${day}`;
                    
                    if (!newActivities[dateKey]) {
                        newActivities[dateKey] = [];
                    }
                    
                    newActivities[dateKey].push({
                        id: event.id,
                        title: event.summary || 'Sans titre',
                        startTime: startDate.toTimeString().slice(0, 5),
                        duration: Math.round((endDate - startDate) / (1000 * 60)),
                        color: event.colorId ? getGoogleColor(event.colorId) : '#3b82f6',
                        description: event.description || ''
                    });
                });
                
                setActivities(newActivities);
                showToast('Synchronisation réussie ✓', 'success');
            };

            const getGoogleColor = (colorId) => {
                const colors = {
                    '1': '#7986cb', '2': '#33b679', '3': '#8e24aa', '4': '#e67c73',
                    '5': '#f6c026', '6': '#f5511d', '7': '#039be5', '8': '#616161',
                    '9': '#3f51b5', '10': '#0b8043', '11': '#d60000'
                };
                return colors[colorId] || '#3b82f6';
            };

            const showToast = (message, type = 'info') => {
                setToast({ message, type });
                setTimeout(() => setToast(null), 3000);
            };

            const renderCircleView = () => {
                const svgSize = Math.min(window.innerWidth - 40, 800);
                const centerX = svgSize / 2;
                const centerY = svgSize / 2;
                const outerRadius = svgSize * 0.38;
                const innerRadius = svgSize * 0.31;
                const middleRadius = (outerRadius + innerRadius) / 2;
                const anglePerDay = (2 * Math.PI) / cycleConfig.cycleLength;
                
                const today = new Date();
                const currentCycleDay = getCycleDay(today);
                const displayDay = selectedCircleDay || currentCycleDay;
                
                // Rotation pour mettre le jour actuel en haut
                const rotationOffset = -((currentCycleDay - 0.5) * anglePerDay);
                const rotationDegrees = rotationOffset * 180 / Math.PI;

                return (
                    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', padding: '20px' }}>
                        <svg width={svgSize} height={svgSize} viewBox={`0 0 ${svgSize} ${svgSize}`}>
                            {/* Flèche fixe en haut */}
                            <polygon
                                points={`${centerX},${centerY - outerRadius - 10} ${centerX - 12},${centerY - outerRadius - 25} ${centerX + 12},${centerY - outerRadius - 25}`}
                                fill="#4b5563"
                                stroke="#374151"
                                strokeWidth="1.5"
                                style={{ filter: 'drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3))' }}
                            />
                            
                            {/* Segments rotatifs */}
                            <g transform={`rotate(${rotationDegrees} ${centerX} ${centerY})`}>
                            {Array.from({ length: cycleConfig.cycleLength }, (_, i) => {
                                const cycleDay = i + 1;
                                const phaseInfo = getPhaseInfo(cycleDay, cycleConfig.cycleLength);
                                const date = getDateForCycleDay(cycleDay);
                                const isToday = cycleDay === currentCycleDay;
                                const isSelected = cycleDay === displayDay;
                                
                                const startAngle = -Math.PI / 2 + i * anglePerDay;
                                const endAngle = startAngle + anglePerDay;
                                
                                const x1 = centerX + outerRadius * Math.cos(startAngle);
                                const y1 = centerY + outerRadius * Math.sin(startAngle);
                                const x2 = centerX + outerRadius * Math.cos(endAngle);
                                const y2 = centerY + outerRadius * Math.sin(endAngle);
                                const x3 = centerX + innerRadius * Math.cos(endAngle);
                                const y3 = centerY + innerRadius * Math.sin(endAngle);
                                const x4 = centerX + innerRadius * Math.cos(startAngle);
                                const y4 = centerY + innerRadius * Math.sin(startAngle);
                                
                                const pathData = `M ${x1} ${y1} A ${outerRadius} ${outerRadius} 0 0 1 ${x2} ${y2} L ${x3} ${y3} A ${innerRadius} ${innerRadius} 0 0 0 ${x4} ${y4} Z`;
                                
                                return (
                                    <path
                                        key={cycleDay}
                                        d={pathData}
                                        fill={phaseInfo.color}
                                        stroke={isToday ? '#2563eb' : (isSelected ? '#374151' : phaseInfo.border)}
                                        strokeWidth={isToday ? 4 : (isSelected ? 3 : 1)}
                                        className="cycle-segment"
                                        onClick={() => {
                                            setSelectedCircleDay(cycleDay);
                                            setSelectedDate(date);
                                        }}
                                    />
                                );
                            })}
                            </g>
                            
                            {/* Textes fixes */}
                            {Array.from({ length: cycleConfig.cycleLength }, (_, i) => {
                                const cycleDay = i + 1;
                                const phaseInfo = getPhaseInfo(cycleDay, cycleConfig.cycleLength);
                                const date = getDateForCycleDay(cycleDay);
                                const moonInfo = getMoonInfo(date);
                                
                                const baseAngle = -Math.PI / 2 + i * anglePerDay + anglePerDay / 2;
                                const adjustedAngle = baseAngle + rotationOffset;
                                
                                const textX = centerX + middleRadius * Math.cos(adjustedAngle);
                                const textY = centerY + middleRadius * Math.sin(adjustedAngle);
                                
                                return (
                                    <g key={`text-${cycleDay}`}>
                                        <text
                                            x={textX}
                                            y={textY - 10}
                                            textAnchor="middle"
                                            dominantBaseline="middle"
                                            style={{ fontSize: '10px', pointerEvents: 'none' }}
                                        >
                                            {moonInfo.emoji}
                                        </text>
                                        <text
                                            x={textX}
                                            y={textY + 1}
                                            textAnchor="middle"
                                            dominantBaseline="middle"
                                            style={{ fontSize: '9px', fontWeight: '700', fill: phaseInfo.text, pointerEvents: 'none' }}
                                        >
                                            J{cycleDay}
                                        </text>
                                        <text
                                            x={textX}
                                            y={textY + 11}
                                            textAnchor="middle"
                                            dominantBaseline="middle"
                                            style={{ fontSize: '8px', fontWeight: '500', fill: phaseInfo.text, pointerEvents: 'none' }}
                                        >
                                            {date.getDate()}/{date.getMonth() + 1}
                                        </text>
                                    </g>
                                );
                            })}
                            
                            {/* Centre blanc */}
                            <circle
                                cx={centerX}
                                cy={centerY}
                                r={innerRadius * 0.95}
                                fill="white"
                                stroke="#e5e7eb"
                                strokeWidth="2"
                            />
                            
                            {/* Contenu central */}
                            <foreignObject
                                x={centerX - innerRadius * 0.85}
                                y={centerY - innerRadius * 0.85}
                                width={innerRadius * 1.7}
                                height={innerRadius * 1.7}
                            >
                                <div style={{
                                    width: '100%',
                                    height: '100%',
                                    display: 'flex',
                                    flexDirection: 'column',
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    padding: '16px',
                                    overflow: 'auto'
                                }}>
                                    {(() => {
                                        const date = getDateForCycleDay(displayDay);
                                        const phaseInfo = getPhaseInfo(displayDay, cycleConfig.cycleLength);
                                        const sunTimes = getSunTimes(date);
                                        const moonInfo = getMoonInfo(date);
                                        const dayActivities = activities[formatDate(date)] || [];

                                        return (
                                            <>
                                                <div style={{ textAlign: 'center', marginBottom: '12px' }}>
                                                    <div style={{ fontSize: '18px', fontWeight: '700', color: phaseInfo.text, marginBottom: '4px' }}>
                                                        J{displayDay} • {phaseInfo.shortName}
                                                    </div>
                                                    <div style={{ fontSize: '11px', color: '#6b7280' }}>
                                                        {date.toLocaleDateString('fr-FR', { weekday: 'short', day: 'numeric', month: 'short' })}
                                                    </div>
                                                    <div style={{ fontSize: '10px', color: '#9ca3af', marginTop: '4px' }}>
                                                        {moonInfo.emoji} {moonInfo.name}
                                                    </div>
                                                    <div style={{ fontSize: '9px', color: '#9ca3af', marginTop: '2px' }}>
                                                        ☀️ {sunTimes.sunrise} → {sunTimes.sunset}
                                                    </div>
                                                </div>
                                                
                                                {dayActivities.length > 0 && (
                                                    <div style={{ width: '100%', maxHeight: '120px', overflowY: 'auto' }}>
                                                        {dayActivities.slice(0, 3).map(act => (
                                                            <div
                                                                key={act.id}
                                                                style={{
                                                                    padding: '6px',
                                                                    backgroundColor: act.color,
                                                                    color: 'white',
                                                                    borderRadius: '6px',
                                                                    fontSize: '10px',
                                                                    fontWeight: '600',
                                                                    marginBottom: '4px'
                                                                }}
                                                            >
                                                                {act.startTime} • {act.title}
                                                            </div>
                                                        ))}
                                                        {dayActivities.length > 3 && (
                                                            <div style={{ fontSize: '10px', color: '#9ca3af', textAlign: 'center' }}>
                                                                +{dayActivities.length - 3} autres
                                                            </div>
                                                        )}
                                                    </div>
                                                )}
                                            </>
                                        );
                                    })()}
                                </div>
                            </foreignObject>
                        </svg>
                    </div>
                );
            };

            const Toast = ({ message, type }) => {
                const colors = {
                    success: '#16a34a',
                    error: '#ef4444',
                    info: '#3b82f6'
                };

                return (
                    <div className="toast" style={{ borderLeft: `4px solid ${colors[type]}` }}>
                        <span style={{ fontSize: '14px', fontWeight: '500' }}>{message}</span>
                    </div>
                );
            };

            return (
                <div style={{ minHeight: '100vh', backgroundColor: '#f9fafb' }}>
                    {/* Header */}
                    <div style={{
                        backgroundColor: 'white',
                        borderBottom: '1px solid #e5e7eb',
                        padding: '16px 24px',
                        display: 'flex',
                        justifyContent: 'space-between',
                        alignItems: 'center'
                    }}>
                        <h1 style={{
                            margin: 0,
                            fontSize: '24px',
                            fontWeight: '700',
                            background: 'linear-gradient(135deg, #ec4899 0%, #8b5cf6 100%)',
                            WebkitBackgroundClip: 'text',
                            WebkitTextFillColor: 'transparent'
                        }}>
                            Lunarium 🌸
                        </h1>

                        <button
                            onClick={() => setShowConfigModal(true)}
                            style={{
                                padding: '8px 16px',
                                backgroundColor: 'white',
                                color: '#6b7280',
                                borderRadius: '8px',
                                cursor: 'pointer',
                                border: '1px solid #e5e7eb',
                                display: 'flex',
                                alignItems: 'center',
                                gap: '8px',
                                fontSize: '14px',
                                fontWeight: '500'
                            }}
                        >
                            <SettingsIcon />
                            Configuration
                        </button>
                    </div>

                    {/* Contenu */}
                    <div style={{ padding: '24px' }}>
                        <GoogleCalendarSync
                            onSync={syncFromGoogleCalendar}
                            onError={(msg) => showToast(msg, 'error')}
                        />

                        <div style={{
                            background: 'white',
                            borderRadius: '12px',
                            padding: '24px',
                            boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
                        }}>
                            {renderCircleView()}
                        </div>
                    </div>

                    {/* Modals */}
                    {showConfigModal && (
                        <ConfigModal
                            config={cycleConfig}
                            onSave={(newConfig) => {
                                setCycleConfig(newConfig);
                                setShowConfigModal(false);
                                showToast('Configuration enregistrée ✓', 'success');
                            }}
                            onClose={() => setShowConfigModal(false)}
                        />
                    )}

                    {/* Toast */}
                    {toast && <Toast message={toast.message} type={toast.type} />}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<LunariumPlanner />);
    </script>
</body>
</html>
